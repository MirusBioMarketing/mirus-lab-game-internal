<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
</head>
<body style="margin: 0; background: #222;">
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 450,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: { gravity: { y: 800 }, debug: false, fps: 120}
            },
            scene: { preload: preload, create: create, update: update }
        };

        const game = new Phaser.Game(config);
            let player, cursors, tubes, lastFired = 0;
            let currentWeapon = 'PolymerP';
            let capsids;
            let weaponStats = {
                'PolymerP': { speed: 300, fireRate: 500, damage: 1, texture: 'tubeP' },
                'PolymerF': { speed: 500, fireRate: 300, damage: 1.6, texture: 'tubeF' },
                'VirusGEN': { speed: 800, fireRate: 150, damage: 2.5, texture: 'tubeV' }
            };
            let boss;
            let bossState = 'attacking';
            let bossTimer = null;
            let bossHP = 50;
            let bossMaxHP = 50;
            let bossHealthBar;
            let playerHP = 50;
            let healthText;
            let revITActive = false;
            // let stabilizerActive = false;
            let totalScore = 0;

        function preload() {
            //Load your Scientist (384px wide / 6 frames = 64px per frame)
            this.load.spritesheet('scientist', 'assets/Scientist01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('item_F', 'assets/ItemPolymerF01.webp');
            this.load.image('item_VirusGEN', 'assets/ItemVirusGEN01.webp');
            this.load.image('tubeP', 'assets/TubeProjectilePolymerP01.webp');
            this.load.image('tubeF', 'assets/TubeProjectilePolymerF01.webp');
            this.load.image('tubeV', 'assets/TubeProjectileVirusGEN01.webp');
            this.load.image('item_P', 'assets/ItemPolymerP01.webp');
            this.load.image('capsid_full', 'assets/CapsidFull01.webp');
            this.load.image('capsid_empty', 'assets/CapsidEmpty01.webp');
            this.load.spritesheet('platform02tiles', 'assets/Tileset_Platform_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('bossClosed', 'assets/BossBioreactorClosed01.png');
            this.load.spritesheet('bossStages', 'assets/Bioreactor_Boss_01.webp', { frameWidth: 256, frameHeight: 256 });
            this.load.image('BasementTile', 'assets/BasementTile01.webp');
            this.load.image('door', 'assets/Door01.webp');
            this.load.spritesheet('transSelectButton', 'assets/TransfectionSelectionButtonTiles01.webp', { frameWidth: 126, frameHeight: 24 });
            this.load.image('bakeoffNotebook', 'assets/BakeoffNotebook01.webp');
            this.load.image('blockSpace', 'assets/BuildingBlock01.webp');
            this.load.spritesheet('FloatingPlatform', 'assets/FloatingPlatformSprites01.webp', { frameWidth: 64, frameHeight: 48 });
            this.load.image('item_RevIT', 'assets/ItemRevIT01.webp');
            this.load.image('item_Stabilizer', 'assets/ItemStabilizer01.webp');
            this.load.image('notebookPF', 'assets/NotebookPF01.webp');
            this.load.image('notebookPP', 'assets/NotebookPP01.webp');
            this.load.image('notebookVG', 'assets/NotebookVG01.webp');
            this.load.spritesheet('verticalWall', 'assets/VerticalWallTileSheet01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('floorTile', 'assets/FloorTile01.webp');
            this.load.spritesheet('toolUIimg', 'assets/ToolUI01.webp', { frameWidth: 192, frameHeight: 64 }); 
            this.load.image('labmatePortrait', 'assets/LabmateHead01.webp');
            this.load.spritesheet('labmateMouth', 'assets/LabmateMouth01.webp', { frameWidth: 16, frameHeight: 16 }); 
            this.load.image('benchBackground', 'assets/BenchtopTile01.webp');
            this.load.spritesheet('labmateIdle', 'assets/labMateTileSprite01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('item_notebook', 'assets/ItemBakeOff01.webp');
            this.load.image('large_notebook', 'assets/BakeoffNotebook01.webp');
            this.load.spritesheet('shearEmitter', 'assets/shearingEmitter01.webp', { frameWidth: 32, frameHeight: 32 });
            this.load.spritesheet('shearLaser01', 'assets/shearingLaser01.webp', { frameWidth: 32, frameHeight: 64 });
            this.load.image('shearLaser02', 'assets/shearingLaser02.webp');
            this.load.image('powerup_crate', 'assets/ItemVirusGEN01.webp');
            this.load.image('modal_bg', 'assets/modalBG01.webp');
            this.load.spritesheet('avatar_biz', 'assets/avatarBiz01.webp', { frameWidth: 120, frameHeight: 90 });
            this.load.spritesheet('avatar_rnd', 'assets/avatarRnd01.webp', { frameWidth: 120, frameHeight: 90 });
            this.load.spritesheet('avatar_mirus', 'assets/avatarMirus01.webp', { frameWidth: 120, frameHeight: 90 });
            this.load.spritesheet('avatar_player', 'assets/avatarPlayer01.webp', { frameWidth: 120, frameHeight: 90 });
            this.load.spritesheet('intro_biz', 'assets/BizDev_Idle_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.spritesheet('intro_RnD', 'assets/RnD_Idle_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('biz_bg', 'assets/boardRoom_01.webp');
            this.load.image('rnd_bg', 'assets/labMeeting_01.webp');
            this.load.spritesheet('mirusFAS_npc', 'assets/FAS_idlethrow_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.spritesheet('mirusReg_npc', 'assets/Regulatory_idlejog_01.webp', { frameWidth: 64, frameHeight: 64});
            this.load.spritesheet('start_bg', 'assets/WelcomeScreen01.webp', { frameWidth: 800, frameHeight: 450 });
            this.load.spritesheet('generator', 'assets/Generator_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.spritesheet('poof', 'assets/Poof_01.webp', { frameWidth: 32, frameHeight: 32 });
            this.load.image('hvac', 'assets/HVAC_01.webp');
            this.load.image('smog01', 'assets/Smog_01.webp');
            this.load.image('skull', 'assets/Skull01.webp');
            this.load.spritesheet('friedNPC', 'assets/FriedNPC_01.webp', { frameWidth: 64, frameHeight: 32 });
            this.load.spritesheet('mime', 'assets/Mime_Support_01.webp', { frameWidth: 64, frameHeight: 64 });
            this.load.image('bgWall01', 'assets/BG_tiles_01.webp');
            this.load.image('bgWall00', 'assets/BG_sec0_01.webp');
            this.load.image('mirusSales_npc', 'assets/Sales_01.webp');
            this.load.image('startScreen_01', 'assets/WelcomeScreen02.webp');
            this.load.image('load_BG01_01', 'assets/Loading_Screen_BG.webp');
            this.load.image('load_FG01_01', 'assets/Loading_Screen_FG.webp');
            this.load.image('lobby01', 'assets/lobby01.png');
            this.load.image('boss_BG', 'assets/bossBG01.webp');
            this.load.spritesheet('marquee', 'assets/Marquee01.webp', { frameWidth: 400, frameHeight: 240 });


        }

        function create() {
            // 1. SCENE CONSTANTS
            let section1Shift = 2400; // section 1 shift starts at x=2000
            let section2Shift = section1Shift + 2600; // section 2 shift starts at x=5000
            let section3Shift = section2Shift + 2400; // section 3 shift starts at x=7400
            let section4Shift = section3Shift + 2500; // section 4 shift starts at x=9900
            let bossRoomShift = section4Shift + 3800; // boss room starts at x=12200
            let bossRoomEnd = bossRoomShift + 800; // boss room ends at x=13000
            let mainFloorY = 430;
            let bossFloorY = mainFloorY + 370;
            this.speedLimited = true;
            this.section1Shift = section1Shift;
            this.section2Shift = section2Shift;
            this.section3Shift = section3Shift;
            this.section4Shift = section4Shift;
            this.bossRoomShift = bossRoomShift;
            this.bossRoomEnd = bossRoomEnd;
            this.scoreThreshold = 10000000000; // 10 billion points to win
            this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            this.isPaused = false;
            this.pauseModal = null;
            this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
            this.stabilizerActive = false;
            this.revITItems = this.add.group();
            this.stabilizerItems = this.add.group();
            this.bossFloorY = bossFloorY;
            // 2. PHYSICS GROUPS
            tubes = this.physics.add.group();
            capsids = this.physics.add.group();
            this.capsids = capsids;
            this.pickups = this.physics.add.staticGroup();
            this.platforms = this.physics.add.staticGroup();
            this.movingPlatforms = this.physics.add.group({
                allowGravity: false,
                immovable: true
            })

            // DEBUG
            // --- COORDINATE DEBUGGER ---
            this.debugActive = false;
            this.debugSpawned = false; 

            // 2. Define the Master Spawn Function
            this.createDebugTools = () => {
                if (this.debugSpawned) return; 
                this.debugSpawned = true;

                // A. The Portal Factory
                const spawnPortal = (x, y, label, targetX) => {
                    let p = this.add.rectangle(x, y, 60, 60, 0xff0000);
                    this.add.text(x - 50, y - 50, label, { fill: '#f00', fontWeight: 'bold' });
                    this.physics.add.existing(p, true);
                    
                    this.physics.add.overlap(this.player, p, () => {
                        this.player.setPosition(targetX, 350);
                        this.cameras.main.scrollX = targetX - (this.cameras.main.width / 2);
                    });
                };

                // B. Spawn Portals (Using 'this' to access your scene constants)
                spawnPortal(200, 300, 'BOSS WARP', this.bossRoomShift - 400);
                spawnPortal(300, 300, 'SEC 1 WARP', this.section1Shift - 400);
                spawnPortal(400, 300, 'SEC 2 WARP', this.section2Shift - 400);
                spawnPortal(500, 300, 'SEC 3 WARP', this.section3Shift - 400);
                spawnPortal(600, 300, 'SEC 4 WARP', this.section3Shift - 400);
                spawnPortal(this.section1Shift + 430, 150, 'SEC 3 WARP', this.section3Shift - 400);

                // C. Draw the Grid
                const gridGraphics = this.add.graphics().setDepth(10000);
                
                // Section Markers
                gridGraphics.lineStyle(4, 0xff0000, 0.8);
                const sections = [0, this.section1Shift, this.section2Shift, this.section3Shift, this.section4Shift, this.bossRoomShift];
                sections.forEach((s, index) => {
                    gridGraphics.lineBetween(s, 0, s, 800);
                    this.add.text(s + 5, 50, `SECTION ${index} START`, { 
                        fontSize: '18px', fill: '#ff0000', backgroundColor: '#000' 
                    });
                });

                // 100px Grid Lines
                gridGraphics.lineStyle(1, 0x00ff00, 0.3);
                for (let x = 0; x < 15000; x += 100) {
                    gridGraphics.lineBetween(x, 0, x, 800);
                    if (x % 500 === 0) {
                        this.add.text(x, 10, x, { fontSize: '10px', fill: '#00ff00' });
                    }
                }

                // Y-Axis Labels
                for (let y = 0; y < 800; y += 50) {
                    gridGraphics.lineBetween(0, y, 15000, y);
                    let yLabel = this.add.text(5, y, `Y:${y}`, { fontSize: '10px', fill: '#00ff00' });
                    yLabel.setScrollFactor(0);
                }
                
                // Turn on physics hitboxes
                if (this.physics.world.debugGraphic) {
                    // If it exists, just show it
                    this.physics.world.debugGraphic.setVisible(true);
                } else {
                    // If it doesn't exist (because config debug was false), create it now
                    this.physics.world.createDebugGraphic();
                }
            };

            // 11. ANIMATIONS
            this.anims.create({
                key: 'idle',
                frames: [{ key: 'scientist', frame: 0 }],
                frameRate: 10
            });
            this.anims.create({
                key: 'walk',
                frames: this.anims.generateFrameNumbers('scientist', { start: 1, end: 4 }),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'throw',
                frames: [{ key: 'scientist', frame: 5 }],
                frameRate: 20
            });

            // NPC idle pose animation
            this.anims.create({
                key: 'labmate_idle_anim',
                frames: this.anims.generateFrameNumbers('labmateIdle', { start: 0, end: 3 }),
                frameRate: 6,
                repeat: -1
            });
            // this.labmate = this.add.sprite(1800, mainFloorY, 'labmateIdle');
            // this.labmate.setOrigin(0.5, 1).setDepth(20);
            // this.labmate.play('labmate_idle_anim');
            
            this.anims.create({
                key: 'platform_move',
                frames: this.anims.generateFrameNumbers('FloatingPlatform', { start: 0, end: 3 }),
                frameRate: 8,
                repeat: -1
            });
            this.movingPlatforms = this.physics.add.group({
                allowGravity: false,
                immovable: true
            });
            this.anims.create({
                key: 'shear_emit_charge',
                frames: this.anims.generateFrameNumbers('shearEmitter', { start: 1, end: 2 }),
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'shear_emit_active',
                frames: this.anims.generateFrameNumbers('shearEmitter', { start: 3, end: 5 }),
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'loop_biz',
                frames: this.anims.generateFrameNumbers('avatar_biz', { start: 0, end: 5 }),
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'loop_rnd',
                frames: this.anims.generateFrameNumbers('avatar_rnd', { start: 0, end: 5 }),
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'loop_mirusteam',
                frames: this.anims.generateFrameNumbers('avatar_mirus', { start: 0, end: 7 }),
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'loop_selfie',
                frames: this.anims.generateFrameNumbers('avatar_player', { start: 0, end: 5 }),
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'rnd_speak',
                frames: this.anims.generateFrameNumbers('intro_RnD', { start: 0, end: 5 }),
                frameRate: 6,
                repeat: -1
            });
            this.anims.create({
                key: 'biz_speak',
                frames: this.anims.generateFrameNumbers('intro_biz', { start: 0, end: 5 }),
                frameRate: 6,
                repeat: -1
            });
            this.anims.create({
                key: 'mirus_throw',
                frames: this.anims.generateFrameNumbers('mirusFAS_npc', { start: 1, end: 5}),
                frameRate: 8,
                repeat: 0 // Play once per trigger
            });
            this.anims.create({
                key: 'reg_walk',
                frames: this.anims.generateFrameNumbers('mirusReg_npc', { start: 1, end: 5}),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'start_anim',
                frames: this.anims.generateFrameNumbers('start_bg', { start: 0, end: 5 }),
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'impact_poof',
                frames: this.anims.generateFrameNumbers('poof', { start: 0, end: 7 }),
                frameRate: 20,
                hideOnComplete: true
            });
            this.anims.create({
                key: 'mime_support',
                frames: this.anims.generateFrameNumbers('mime', { start: 0, end: 5 }),
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'mouthloop',
                frames: this.anims.generateFrameNumbers('labmateMouth', { start: 0, end: 9 }),  
                frameRate: 8,
                repeat: -1
            });
            
            this.anims.create({
                key: 'boss_attack_anim',
                frames: this.anims.generateFrameNumbers('bossStages', { start: 0, end: 19 }),  
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'boss_defend_anim',
                frames: this.anims.generateFrameNumbers('bossStages', { start: 20, end: 39 }),  
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'boss_vulnerable_anim',
                frames: this.anims.generateFrameNumbers('bossStages', { start: 40, end: 49 }),  
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'marquee_lights',
                frames: [
                    { key: 'marquee', frame: 0, duration: 2000 }, // Stay on frame 0 for 2 seconds
                    { key: 'marquee', frame: 1, duration: 200 },  // Quick blink
                    { key: 'marquee', frame: 2, duration: 200 }   // Quick blink
                ],
                frameRate: 10, // This is the base speed for the non-duration frames
                repeat: -1
            });
            
            // 3. GAME OBJECTS -PLAYER & BOSS
            player = this.physics.add.sprite(100, 300, 'scientist');
            player.body.setCollideWorldBounds(true);
            player.body.setSize(40, 64);
            player.body.setOffset(12, 0);
            player.setDepth(30);
            this.player = player;

            boss = this.physics.add.sprite(bossRoomShift + 600, bossFloorY, 'bossClosed').setOrigin(0.5,1);
            boss.body.setAllowGravity(false);
            boss.setImmovable(true);
            boss.hp = 50;

             // Initialize all scene-level variables
            this.currentWeapon = null;
            this.lastFired = 0;
            this.revITActive = false;
            this.stabilizerActive = false;
            this.bossState = 'attacking';
            this.bossTimer = null;
            this.bossHP = 50;
            this.bossMaxHP = 50;
            playerHP = 50;
            this.controlsEnabled = true;
            this.challengeStarted = false;
            bossStarted = false
            this.gameStarted = false;
            
            this.weaponStats = {
                'PolymerP': { speed: 300, fireRate: 500, damage: 1, texture: 'tubeP' },
                'PolymerF': { speed: 500, fireRate: 300, damage: 1.6, texture: 'tubeF' },
                'VirusGEN': { speed: 800, fireRate: 150, damage: 2.5, texture: 'tubeV' }
            };

            // 4. ENVIRONMENT & WORLD
            this.add.tileSprite(0, mainFloorY, bossRoomShift, 40, 'floorTile').setOrigin(0, 0);
            this.add.tileSprite(bossRoomShift, bossFloorY, bossRoomEnd - bossRoomShift, 40, 'floorTile').setOrigin(0, 0);

            let groundWidth = bossRoomShift; 
            let mainGround = this.add.rectangle(0, mainFloorY, groundWidth, 40).setOrigin(0, 0).setVisible(false);
            this.physics.add.existing(mainGround, true);
            this.platforms.add(mainGround);

            let bossFloor = this.add.rectangle(bossRoomShift, bossFloorY + 40, bossRoomEnd - bossRoomShift, 40).setVisible(false);
            this.physics.add.existing(bossFloor, true);
            this.platforms.add(bossFloor);

            createVerticalWall(this, bossRoomShift, 440, 4, this.platforms);
            createVerticalWall(this, bossRoomEnd, 440, 4, this.platforms);
            createVerticalWall(this, section4Shift + 1530, 0, 2, this.platforms);

            // 5. ENVIRONMENT
            // --- BACKGROUNDS
            // --- SECTION PRE

            // --- SECTION 0
            this.bg0 = this.add.image(600, 0, 'bgWall00')
                .setOrigin(0, 0)
                .setScrollFactor(0.8)
                .setDepth(-19);

            // It covers the screen from X:0 to X:2000
            const maskGraphics0 = this.make.graphics();
            maskGraphics0.fillRect(0, 0, this.section1Shift, 800);

            // 2. Create the mask from that shape
            const section0Mask = maskGraphics0.createGeometryMask();

            // 3. Apply the mask to your Section 0 background
            this.bg0.setMask(section0Mask);

            // --- SECTION 1
            let scrollLag1 = this.section1Shift * (1 - 0.8);
            let bgStart1 = this.section1Shift - scrollLag1;
            this.bg1 = this.add.tileSprite(bgStart1, 0, 1950, 430, 'bgWall01')
                .setOrigin(0, 0)
                .setScrollFactor(0.8)
                .setDepth(-20);
            
            // --- SECTION 2
            let scrollLag2 = this.section2Shift * (1 - 0.8);
            let bgStart2 = this.section2Shift - scrollLag2;
            this.bg2 = this.add.tileSprite(bgStart2, 0, 1950, 430, 'bgWall01')
                .setOrigin(0, 0)
                .setScrollFactor(0.8)
                .setDepth(-20);

            // --- SECTION 3
            let scrollLag3 = this.section3Shift * (1 - 0.8);
            let bgStart3 = this.section3Shift - scrollLag3;
            this.bg3 = this.add.tileSprite(bgStart3, 0, 1950, 430, 'bgWall01')
                .setOrigin(0, 0)
                .setScrollFactor(0.8)
                .setDepth(-20);

            // --- SECTION 4
            let scrollLag4 = this.section4Shift * (1 - 0.8);
            let bgStart4 = this.section4Shift - scrollLag4;
            this.bg4 = this.add.tileSprite(bgStart4, 0, 3450, 430, 'bgWall01')
                .setOrigin(0, 0)
                .setScrollFactor(0.8)
                .setDepth(-20);
            
            // --- Section 1A intro --- clean room
            let introSquare = this.add.image(368, -475, 'blockSpace').setOrigin(0.5, 0).setDepth(10);
            this.physics.add.existing(introSquare, true);

            this.lobby = this.add.container(0, 0).setDepth(-5);
            let lobbySprite = this.add.sprite(750, 430, 'lobby01').setOrigin(1, 1).setScrollFactor(1);
            this.lobby.add(lobbySprite);


            this.door1A = this.physics.add.image(748, 305, 'door').setImmovable(true).setDepth(9);
            this.door1A.body.setAllowGravity(false);
            addDialogueTrigger(this, 600, 430, 100, 200, () => {
                let msg = "Hey! Help me with this AAV therapeutic. Meet me at the bench.";
                startBlockingDialogue(this, msg, () => {
                    // This runs after they press SPACE
                    if (this.door1A) {
                        this.tweens.add({ targets: this.door1A, y: this.door1A.y - 80, duration: 2000 });
                    }
                });
            });

            [section1Shift, section2Shift, section3Shift, section4Shift].forEach((shift, i) => {
                let sq = this.add.image(shift, -475, 'blockSpace').setOrigin(0.5, 0).setDepth(10);
                this.physics.add.existing(sq, true);
                this.physics.add.collider(player, sq);
            });

            // --- Section 1C intro --- bench space, get polymer p
            this.benchBacking1 = this.add.tileSprite(section1Shift, mainFloorY, 800, 200, 'benchBackground');
            this.benchBacking1.setOrigin(0.5, 1);
            this.benchBacking1.setDepth(-5);
            // Labmate NPC
            spawnLabmate (this, section1Shift + 200, mainFloorY);
            // Door 2
            this.door1C = this.physics.add.image(section1Shift + 380, 305, 'door');
            this.door1C.body.setAllowGravity(false);
            this.door1C.setImmovable(true);
            this.door1C.setDepth(9);
            addDialogueTrigger(this, section1Shift + 200, 430, 100, 200, () => {
                let msg = "Start delivering nucleic acids to the cell line. We need to maximize our titer and percent-full capsids. Use Polymer P. It has been a reliable method for decades. Capture as many full capsids as possible.";
                startBlockingDialogue(this, msg, () => {
                    // This runs after they press SPACE
                    if (this.door1C) {
                        this.tweens.add({ targets: this.door1C, y: this.door1C.y - 80, duration: 2000 });
                    }
                });
            });

            // Speed Trigger: Remove speed limit after they enter section 1
            let speedTrigger = this.add.zone(section1Shift + 300, mainFloorY, 100, 400);
            this.physics.add.existing(speedTrigger, true);

            this.physics.add.overlap(player, speedTrigger, () => {
                this.speedLimited = false; // "Natural" speed increase happens here
                speedTrigger.destroy();
            }, null, this);

            // CDMO NPC near generator
            this.cdmoNPC = this.add.sprite(section1Shift + 558, mainFloorY -64, 'mirusFAS_npc').setOrigin(0.5, 1);
            this.cdmoNPC.setTint(0x808080);
                        
            // --- Section 2 Lab --- bench space, get polymer f
            this.benchBacking2 = this.add.tileSprite(section2Shift, mainFloorY, 800, 200, 'benchBackground');
            this.benchBacking2.setOrigin(0.5, 1);
            this.benchBacking2.setDepth(-5);
            // Labmate NPC
            spawnLabmate (this, section2Shift + 200, mainFloorY);
            // Section 2 door
            this.door2 = this.physics.add.image(section2Shift + 380, 305, 'door');
            this.door2.body.setAllowGravity(false);
            this.door2.setImmovable(true);
            this.door2.setDepth(9);
            addDialogueTrigger(this, section2Shift + 200, 430, 100, 200, () => {
                let msg = "Try PolymerF. It's a lipid-polymer reagent that can improve delivery. Watch out for more shearing, and regulatory traps. The transfection complexation window makes scaling difficult.";
                startBlockingDialogue(this, msg, () => {
                    // This runs after they press SPACE
                    if (this.door2) {
                        this.tweens.add({ targets: this.door2, y: this.door2.y - 80, duration: 2000 });
                    }
                });
            });
            
            // --- Section 3 Lab --- bench space, get virusgen
            this.benchBacking3 = this.add.tileSprite(section3Shift, mainFloorY, 800, 200, 'benchBackground');
            this.benchBacking3.setOrigin(0.5, 1);
            this.benchBacking3.setDepth(-5);
            // Labmate NPC
            spawnLabmate (this, section3Shift + 200, mainFloorY);
            // Section 3 door
            this.door3 = this.physics.add.image(section3Shift + 380, 305, 'door');
            this.door3.body.setAllowGravity(false);
            this.door3.setImmovable(true);
            this.door3.setDepth(9);
            addDialogueTrigger(this, section3Shift + 200, 430, 100, 200, () => {
                let msg = "Now try VirusGEN. It's a virus-based delivery system that is built specifically for scaling our virus production. A member of their support team is onsite helping us scale.";
                startBlockingDialogue(this, msg, () => {
                    // This runs after they press SPACE
                    if (this.door3) {
                        this.tweens.add({ targets: this.door3, y: this.door3.y - 80, duration: 2000 });
                    }
                });
            });

            // --- Section 4 Lab --- bench space, get enhancers
            this.benchBacking4 = this.add.tileSprite(section4Shift, mainFloorY, 800, 200, 'benchBackground');
            this.benchBacking4.setOrigin(0.5, 1);
            this.benchBacking4.setDepth(-5);
            // Labmate NPC
            spawnLabmate (this, section4Shift + 200, mainFloorY);
            // Section 4 door
            this.door4 = this.physics.add.image(section4Shift + 380, 305, 'door');
            this.door4.body.setAllowGravity(false);
            this.door4.setImmovable(true);
            this.door4.setDepth(9);
            addDialogueTrigger(this, section4Shift + 200, 430, 100, 200, () => {
                let msg = "Pretty powerful. Try it's enhancer; RevIT boosts production 2-4X! And it's additive VirusGEN Stabilizer extends the transfection complex delivery window up to 180 minutes!";
                startBlockingDialogue(this, msg, () => {
                    // This runs after they press SPACE
                    if (this.door4) {
                        this.tweens.add({ targets: this.door4, y: this.door4.y - 80, duration: 2000 });
                    }
                });
            });

            this.bossMarquee = this.add.sprite(bossRoomShift, mainFloorY - 100, 'marquee').setOrigin(0.5, 1);
            this.bossMarquee.play('marquee_lights');

            // --- BOSS SECTION --- 
            let bossBG = this.add.image(this.bossRoomShift, 0, 'boss_BG').setOrigin(0, 0);
            bossBG.setDisplaySize(800, 800); // Forces the 800x800 dimensions
            bossBG.setDepth(-1);            // Puts it behind everything

            // --- Section 1C --- polymer p
            createPlatform(this, this.platforms, section1Shift + 530, 398, 2);
            createPlatform(this, this.platforms, section1Shift + 988, 398, 2);
            createPlatform(this, this.platforms, section1Shift + 1180, 300, 3);
            createPlatform(this, this.platforms, section1Shift + 1374, 200, 2);
            createPlatform(this, this.platforms, section1Shift + 1168, 100, 2);
            // --- Section 2 --- polymer f
            createPlatform(this, this.platforms, section2Shift + 540, 380, 2);
            createPlatform(this, this.platforms, section2Shift + 732, 300, 3);
            createPlatform(this, this.platforms, section2Shift + 1138, 300, 2);
            createPlatform(this, this.platforms, section2Shift + 1650, 160, 2);
            // --- Section 3 --- virusgen
            createPlatform(this, this.platforms, section3Shift + 450, 160, 2);
            createPlatform(this, this.platforms, section3Shift + 800, 398, 2);
            createPlatform(this, this.platforms, section3Shift + 1050, 300, 3);
            createPlatform(this, this.platforms, section3Shift + 1350, 300, 2);
            // --- Section 4 --- enhancers
            createPlatform(this, this.platforms, section4Shift + 600, 398, 2);
            createPlatform(this, this.platforms, section4Shift + 800, 300, 2);
            createPlatform(this, this.platforms, section4Shift + 914, 200, 2);
            createPlatform(this, this.platforms, section4Shift + 1500, 398, 2);
            createPlatform(this, this.platforms, section4Shift + 2050, 398, 2);
            createPlatform(this, this.platforms, section4Shift + 2250, 300, 2);
            createPlatform(this, this.platforms, section4Shift + 2750, 260, 2);

            // --- section 1 assets ---
            let fried = this.add.sprite(section1Shift + 1948, mainFloorY, 'friedNPC', 0).setDepth(5);
            // 2. The Spasm Logic
            const triggerTwitch = () => {
                fried.setFrame(1); // Twitch frame
                
                // Hold the twitch for a split second
                this.time.delayedCall(100, () => {
                    fried.setFrame(0); // Back to "still"
                    
                    // Schedule next twitch at a random interval (1 to 4 seconds)
                    this.time.delayedCall(Phaser.Math.Between(1000, 4000), triggerTwitch);
                });
            };
            // Start the loop
            triggerTwitch();

            // --- section 2 assets ---
            let mimetech = this.add.sprite(section2Shift + 1650, 128, 'mime').setOrigin(0.5, 1);
            mimetech.play('mime_support');
            mimetech.setDepth(5);

            // --- Moving Platform ---
            this.movingPlatform = this.physics.add.group({
                allowGravity: false,
                immovable: true
            }); 

            let mp = this.movingPlatform.create(section4Shift + 2450, 250, 'FloatingPlatform');
            mp.startX = section4Shift + 2450;
            mp.range = 100;
            mp.speed = 3;
            mp.direction = 1;

            this.physics.add.collider(player, this.movingPlatform);

            // 10. ITEMS & NOTEBOOKS
            // NOTEBOOKS
            // Notebook 1 Conversation 4 polymer P
            this.notebook1 = this.physics.add.sprite(section1Shift + 300, 410, 'item_notebook').setOrigin(0.5, 1).setDepth(15);
            this.notebook1.body.allowGravity = false;
            this.physics.add.overlap(player, this.notebook1, () => {
                collectNotebookP(this); 
            }, null, this);
            // Notebook 2 polymer F
            this.notebook2 = this.physics.add.sprite(section2Shift + 300, 410, 'item_notebook').setOrigin(0.5, 1).setDepth(15);
            this.notebook2.body.allowGravity = false;
            this.physics.add.overlap(player, this.notebook2, () => {
                collectNotebookF(this); 
            }, null, this);
            // Notebook 3 virusgen
            this.notebook3 = this.physics.add.sprite(section3Shift + 300, 410, 'item_notebook').setOrigin(0.5, 1).setDepth(15); 
            this.notebook3.body.allowGravity = false;
            this.physics.add.overlap(player, this.notebook3, () => {
                collectNotebookV(this); 
            }, null, this);
            // ENHANCERS
            // Section 4 Intro Powerups
            createRevIT(this, this.section4Shift + 950, 100);
            createStabilizer(this, this.section4Shift + 1530, 300);

            // Section 4 Challenge Powerups (The ones you wanted to add)
            createRevIT(this, this.section4Shift + 2800, 160); 
            createStabilizer(this, this.section4Shift + 2320, 175);

            // 11. CAPSIDS (Full Spawnpoint List)
            // Spawn Capsids
            let spawnpoints = [
                // --- Section 1 ---
                {x:section1Shift + 988, y:50},
                {x:section1Shift + 1674, y:150},
                // --- Section 2 ---
                {x:section2Shift + 460, y:180}, 
                {x:section2Shift + 1000, y:180},
                {x:section2Shift + 1350, y:50},
                {x:section2Shift + 1450, y:50},
                {x:section2Shift + 1550, y:50},
                // --- Section 3 ---
                {x:section3Shift + 550, y:65},
                {x:section3Shift + 650, y:65},
                {x:section3Shift + 750, y:65},
                {x:section3Shift + 850, y:65},
                {x:section3Shift + 950, y:65},

                {x:section3Shift + 1500, y:205},
                {x:section3Shift + 1550, y:205},
                {x:section3Shift + 1600, y:205},
                {x:section3Shift + 1650, y:205},
                {x:section3Shift + 1700, y:205},

                {x:section3Shift + 1600, y:375},
                {x:section3Shift + 1650, y:375},
                {x:section3Shift + 1700, y:375},
                {x:section3Shift + 1750, y:375},
                {x:section3Shift + 1800, y:375},

                // --- Section 4 ---

                {x:section4Shift + 1150, y:150},
                {x:section4Shift + 1200, y:75},
                {x:section4Shift + 1200, y:150},
                {x:section4Shift + 1200, y:225},
                {x:section4Shift + 1250, y:75},
                {x:section4Shift + 1250, y:150},
                {x:section4Shift + 1250, y:225},
                {x:section4Shift + 1300, y:75},
                {x:section4Shift + 1300, y:75},
                {x:section4Shift + 1300, y:150},
                {x:section4Shift + 1300, y:225},
                {x:section4Shift + 1350, y:75},
                {x:section4Shift + 1350, y:150},
                {x:section4Shift + 1350, y:225},
                {x:section4Shift + 1400, y:75},
                {x:section4Shift + 1400, y:150},
                {x:section4Shift + 1400, y:225},

                {x:section4Shift + 1650, y:310},
                {x:section4Shift + 1700, y:310},
                {x:section4Shift + 1750, y:310},
                {x:section4Shift + 1800, y:310},
                {x:section4Shift + 1850, y:310},
                {x:section4Shift + 1900, y:310},
                {x:section4Shift + 1950, y:310},
                {x:section4Shift + 2000, y:310},

                {x:section4Shift + 2900, y:200},
                {x:section4Shift + 2950, y:215},
                {x:section4Shift + 2950, y:175},
                {x:section4Shift + 3000, y:200},
                {x:section4Shift + 3050, y:215},
                {x:section4Shift + 3050, y:175},
                {x:section4Shift + 3100, y:200},
                {x:section4Shift + 3150, y:215},
                {x:section4Shift + 3150, y:175},
                {x:section4Shift + 3200, y:200},

                {x:bossRoomShift + 200, y:375},
            ];
            spawnpoints.forEach(pos => {
                let cap = capsids.create(pos.x, pos.y, 'capsid_full');
                cap.body.setAllowGravity(false);
                cap.body.checkCollision.none = false;
                cap.body.embedded = true;
                cap.hp = 5; 
                cap.baseY = pos.y; 
            });

            // --- TRAPS ---
            this.trapList = []; // For updating visuals
            this.shearHazards = this.physics.add.group({ allowGravity: false, immovable: true });

            // Spawn Traps
            //createShearTrap(this, 1150, mainFloorY, 0);
            // Section 1 trap cluster
            createShearTrap(this, section1Shift + 2000, mainFloorY, 0);
            // Section 2 trap cluster
            createShearTrap(this, section2Shift + 760, mainFloorY, 330);
            createShearTrap(this, section2Shift + 1080, mainFloorY, 0);
            // Section 3 trap cluster
            createShearTrap(this, section3Shift + 1100, mainFloorY, 330);

            // Global State Timer
            this.trapState = 'charging'; 
            this.time.addEvent({
                delay: 3000,
                callback: () => {
                    const isActive = this.trapState === 'charging';
                    this.trapState = isActive ? 'active' : 'charging';

                    this.trapList.forEach(t => {
                        if (isActive) {
                            t.floorEmit.play('shear_emit_active');
                            t.ceilingEmit.play('shear_emit_active');
                            t.beam.setAlpha(1);
                            t.hazard.enableBody = true; // Turn on damage
                        } else {
                            t.floorEmit.play('shear_emit_charge');
                            t.ceilingEmit.play('shear_emit_charge');
                            t.beam.setAlpha(0.3); // Low opacity warning
                            t.hazard.enableBody = false; // Turn off damage
                        }
                    });
                },
                loop: true
            });

            // Damage Collider for Shear Traps
            this.physics.add.overlap(player, this.shearHazards, (p, h) => {
                if (this.trapState === 'active' && !p.isInvulnerable) {
                    damagePlayer(p, h, this, 20);
                    p.isInvulnerable = true;

                    // Instant Position Snap
                    // Move the player 5 pixels away from the beam immediately 
                    // to prevent overlapping for multiple frames.
                    if (p.x < h.x) {
                        p.x -= 10; 
                        p.body.setVelocityX(-500);
                    } else {
                        p.x += 10;
                        p.body.setVelocityX(500);
                    }

                    // Stun
                    this.controlsEnabled = false;
                    this.time.delayedCall(150, () => {
                        this.controlsEnabled = true;
                    });

                    // Visuals
                    p.setTint(0xff0000);
                    this.tweens.add({
                        targets: p,
                        alpha: 0,
                        duration: 50,
                        yoyo: true,
                        repeat: 5,
                        onComplete: () => { p.alpha = 1; p.isInvulnerable = false; p.clearTint(); }
                    });
                }
            });
            // Shear Trap for Projectiles
            this.physics.add.collider(tubes, this.shearHazards, (tube, hazard) => {
                if (this.trapState === 'active') {
                    // Create a small impact effect
                    let spark = this.add.sprite(tube.x, tube.y, 'shearLaser02').setScale(0.5);
                    this.tweens.add({
                        targets: spark,
                        alpha: 0,
                        scale: 2,
                        duration: 100,
                        onComplete: () => spark.destroy()
                    });

                    tube.destroy(); 
                }
            }, (tube, hazard) => {
                // Process Callback: Only collide if the trap is active
                return this.trapState === 'active';
            }, this);

            // --- BACKGROUND DIALOGUE TRIGGERS ---
            this.vignette1_BG = this.add.image(1050, 200, 'rnd_bg').setDepth(10).setScrollFactor(0.8);
            this.vignette1_Char = this.add.sprite(1050 - 75, 215, 'intro_RnD').setDepth(11).setScrollFactor(0.8);
            this.vignette1_Char.play('rnd_speak');
            this.vignette1Started = false;

            addDialogueTrigger(this, 900, mainFloorY, 100, 450, () => {
                if (!this.vignette1Started) {
                    this.vignette1Started = true;
                    typeSequentialVignette(this, 1050, 300, [
                        "This pharmaceutical asset needs to reach phase II by next quarter.",
                        "We're seeing increased shearing with the new formulation.",
                        "It's taken too long to scale past 200 liters.",
                        "A new transfection reagent should arrive today.",
                        "I ordered enhancers with it, too.",
                        "I saw their data at a conference last year.",
                        "They had a really nice booth",
                        "So I followed them on LinkedIn and their content was actually pretty good",
                        "Where is our process engineer? He was supposed to help with scaling.",
                        "Is that him just standing in the suite, staring at us?",
                        "It is... He's just staring at us.",
                        "Can he hear us?",
                        "Remind me to look at his performance review.",
                        "If he can scale this to 1000 liters, he can stare all he wants.",
                        "Is he looking at the open microcentrifuge tube? He better not throw it."
                    ]);
                }
            });

            this.vignette2_BG = this.add.image(1600, 200, 'biz_bg').setDepth(-2).setScrollFactor(0.8);
            this.vignette2_Char = this.add.sprite(1600 + 75, 215, 'intro_biz').setDepth(-1).setScrollFactor(0.8);
            this.vignette2_Char.play('biz_speak');
            this.vignette2Started = false;

            addDialogueTrigger(this, 1400, mainFloorY, 100, 450, () => {
                if (!this.vignette2Started) {
                    this.vignette2Started = true;
                    typeSequentialVignette(this, 1550, 300, [
                        "We need to lower the cost per-dose for this asset.",
                        "An IND Delay would be a disaster for our market position.",
                        "We want to scale up, not out.",
                        "If we increase our suite turnover, we can hire more MSAT people.",
                        "Do we have a regulatory strategy for this asset?",
                        "We need to find a residual reagent assay fast.",
                        "I want to see a vendor comparison for those kits by the end of the week.",
                        "I saw a presentation on regulatory expectations at a conference last year.",
                        "I followed that speaker on LinkedIn and their content was actually pretty good.",
                        "Is that Process Engineer just staring at us?",
                        "After the RnD leadership meeting, I have to ask them how they hire these people.",
                        "This is why we have a time-card system."
                    ]);
                }
            });

            // friedNPC dialogue trigger
            addDialogueTrigger(this, section1Shift + 1700, 300, 100, 600, () => {
                typeSequentialVignette(this, section1Shift + 1850, 300, [
                    "Shearing killed my cells!",
                    "I knew the risks of pumping so aggressively with this reagent.",
                    "My cells are all dead. My poor cells.",
                    "I saw a poster about 'pumpability' at a conference last year.",
                    "I followed the presenter on LinkedIn and their content was actually pretty good.",
                    "This run is shot and will cost us a lot of time and money.",
                    "I appreciate you sticking around, but I'm okay. This game is kid friendly.",
                    "Only my pride is damaged, if you don't count the customer's timeline and budget."
                ]);
            });

            // SECTION 2 NPC - MIME
            this.mimetechTriggered = false;

            addDialogueTrigger(this, section2Shift + 1300, 250, 200, 350, () => {
                // Force check against the scene variable
                if (this.mimetechTriggered) return; 
                this.mimetechTriggered = true;

                // Note: I changed the X to 1050 (fixed) so it stays centered on screen 
                // instead of following the world shift, which often breaks vignettes.
                typeSequentialVignette(this, section2Shift + 1400, 200, [
                    "I don't think you can reach those capsids, monsieur.",
                    "Try using our competitor's enhancer. It's our best product.",
                    "It's better than Polymer P. Why would we compare to anything else?",
                    "I am on holiday until the end of the quarter.",
                    "Please do not bother me on my break.",
                    "Now leave me alone. This is my only break."
                ]);
            });
            
            // SECTION 3 NPC - MIRUS FAS REP
            // 1. Setup Groups and Aliases
            this.virusgenProjectiles = this.physics.add.group();
            this.capsids = capsids; // Ensure this alias is set before triggers

            // 2. Spawn FAS NPC
            this.mirusFAS1 = this.add.sprite(section3Shift + 450, 128, 'mirusFAS_npc')
                .setOrigin(0.5, 1)
                .setDepth(30);

            // 3. Add Collider (Projectiles hit capsids)
            this.physics.add.overlap(this.virusgenProjectiles, this.capsids, (projectile, capsid) => {
                projectile.destroy();
                capsid.destroy();
                this.score += 10;
                this.scoreText.setText('Score: ' + this.score);
            }, null, this);

            // 4. Trigger: Passive Dialogue (Floor to Ceiling)
            // SALES
            this.mirusSales1 = this.add.sprite(section3Shift + 430, 430, 'mirusSales_npc').setOrigin(0.5, 1).setDepth(30);
            addDialogueTrigger(this, section3Shift + 430, 300, 100, 600, () => {
                typeSequentialVignette(this, section3Shift + 600, 300, [
                    "You get a Field Application Scientist from Mirus Bio!",
                    "I'm your account manager, but I'll let you see what your FAS is working on!"
                ]);
            });
            // FAS
            this.vignetteFASStarted = false;
            addDialogueTrigger(this, section3Shift + 800, 300, 100, 600, () => {
                if (!this.vignetteFASStarted) {
                    this.vignetteFASStarted = true;
                    typeSequentialVignette(this, section3Shift + 1000, 175, [
                        "Hold down space to shoot faster. And call me to scale faster (IRL).",
                        "Plan your tests and scaling strategy with me. I can help!",
                        "I'll come onsite to help you optimize your transfection conditions.",
                        "I'm flattered that you want to talk more now...",
                        "but you didn't extend your complex delivery window with any additives.",
                        "If you aren't serious about titer, maybe don't reach out to me for help."
                    ]);
                }
            });

            // 5. Trigger: Shooting Activation (Floor to Ceiling)
            addDialogueTrigger(this, section3Shift + 650, 300, 100, 600, () => {
                if (this.mirusTimer) return; // Prevent double-looping

                this.mirusTimer = this.time.addEvent({
                    delay: 800,
                    callback: () => {
                        // Check for valid, active targets in range
                        let targets = this.capsids.getChildren().filter(c => 
                            c.active === true && 
                            c.visible === true && 
                            c.x > this.mirusFAS1.x && 
                            c.x < (this.mirusFAS1.x + 550)
                        );
                        
                        if (targets.length > 0) {
                            mirusShoot(this);
                        } else {
                            // STOP shooting logic
                            if (this.mirusTimer) {
                                this.mirusTimer.remove();
                                this.mirusTimer = null;
                            }
                            this.mirusFAS1.stop();
                            this.mirusFAS1.setFrame(0);
                        }
                    },
                    callbackScope: this,
                    loop: true
                });
            });

            // REGULATORY TRIGGERS AND MORE
            // REGULATORY NPC SETUP
            this.regulatoryNPC = this.physics.add.sprite(0, 0, 'mirusReg_npc')
                .setOrigin(0.5, 1)
                .setDepth(100)
                .setVisible(false);

            this.regulatoryNPC.body.setAllowGravity(false);
            this.regFollowing = false;
            this.activeRegText = null;

            // TRIGGER
            addDialogueTrigger(this, this.section4Shift + 3100, 300, 100, 600, () => {
                if (!this.regFollowing) {
                    // Force spawn 400px behind the player's current position
                    this.regulatoryNPC.x = this.player.x - 400;
                    this.regulatoryNPC.y = mainFloorY;
                    this.regulatoryNPC.setVisible(true);
                    this.regFollowing = true;
                    
                    typeSequentialVignette(this, this.regulatoryNPC.x, this.regulatoryNPC.y - 130, [
                        "Our recent residual reagent assays showed zero issues; keep that momentum going!",
                        "You're assigned FAS member will be onsite to help you scale to 1000 liters.",
                        "We filed all recent documents on time; no delays means we're on track for your scale-up!", 
                        "Thanks to thorough analytical validation, we've eliminated CMC shortcomings; your path to success is clear!",
                        "Material selection is spot on; the approved reagents will enhance your production efficiency!",
                        "Documentation is tight; every step is recorded, ensuring a smooth regulatory review ahead!",
                        "With our solid track record, we're ready to tackle this scale-up; let's achieve those targets together!",
                        "Just because we're on-schedule doesn't mean you can listen to me all day. Go work on scaling that process!"
                    ], this.regulatoryNPC);
                }
            });


            //7.INPUTS & HUD
            cursors = this.input.keyboard.createCursorKeys();
            this.fireKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

            this.score = 0;
            this.health = 100;
            this.timeLeft = 900;

            this.scoreText = this.add.text(20, 20, 'CAPSIDS CAPTURED: 0', { fontSize: '18px', fill: '#00ff00', backgroundColor: '#000000' }).setScrollFactor(0).setDepth(3000).setVisible(false);
            this.healthText = this.add.text(20, 80, 'HEALTH: 100%', { fontSize: '18px', fill: '#00ff00' }).setScrollFactor(0).setDepth(3000).setVisible(false);

            // Timer
            this.timerText = this.add.text(20, 50, 'TIME: ' + this.timeLeft, { fontSize: '18px', fill: '#fff' }).setScrollFactor(0).setDepth(3000).setVisible(false);
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    if (this.challengeStarted) { 
                        this.timeLeft--;
                        if (this.timerText) {
                            this.timerText.setText('TIME: ' + this.timeLeft);
                        }
                    }
                },
                callbackScope: this,
                loop: true
            });

            // Tool UI
            this.toolUI = this.add.container(400, 550).setScrollFactor(0).setDepth(2000);
            this.reagentDisplay = this.add.sprite(0, 0, 'toolUIimg', 0);
            this.toolUI.add(this.reagentDisplay)
            this.toolUI.setVisible(false);
            
            // 8. PHYSICS INTERACTIONS
            this.physics.add.collider(player, this.platforms);
            this.physics.add.collider(player, this.movingPlatforms);
            this.physics.add.collider(tubes, this.platforms, (t) => t.destroy());

            setupContaminationHazard(
                this, 
                section1Shift + 772,  // Hazard X
                mainFloorY,           // Hazard Y
                section1Shift + 850, // Generator X (Far Right)
                320,                 // Generator Y (On a platform)
                2,                   // Damage Scale
                player, 
                tubes
            );
            
            this.physics.add.overlap(tubes, capsids, hitCapsid, null, this);
            this.physics.add.overlap(tubes, boss, hitBoss, null, this);
            this.physics.add.overlap(player, capsids, damagePlayer, null, this);
            // this.physics.add.overlap(player, trap, () => damagePlayer(this, 0.2));
            this.physics.add.overlap(player, this.introTrigger, () => { startIntroDialogue(this); this.introTrigger.destroy(); }, null, this);

            // 9. CAMERA
            this.physics.world.setBounds(0, 0, bossRoomEnd + 20, 800);
            this.cameras.main.setBounds(0, 0, bossRoomEnd + 20, 900);
            this.cameras.main.startFollow(player, true, 0.1, 0.1, 0, 100);
            this.cameras.main.setDeadzone(50, 50);
            
            // --- INTRO + LOADING
            this.startBG = this.add.sprite(400, 225, 'startScreen_01').setDepth(10000).setScrollFactor(0);

            this.startPrompt = this.add.text(400, 400, 'PRESS SPACE TO START OPTIMIZING TITER', {
                fontSize: '20px', fill: '#ffffff', backgroundColor: '#000'
            }).setOrigin(0.5).setDepth(10001).setScrollFactor(0);

            this.physics.pause();

            this.input.keyboard.once('keydown-SPACE', () => {
                // 1. Clear Start Screen
                this.startBG.destroy();
                this.startPrompt.destroy();

                // 2. Setup Loading Assets (Instructions + Man)
                let loadBG = this.add.image(400, 225, 'load_BG01_01').setScrollFactor(0).setDepth(10000);
                let man = this.add.image(825, 225, 'load_FG01_01').setOrigin(1, 0.5).setScrollFactor(0).setDepth(10001);
                let loadText = this.add.text(40, 380, 'Press or Hold \n[SPACE] to\nshoot & collect full capsids', {
                    fontSize: '18px', fill: '#ffffff', fontFamily: 'Courier New',
                }).setDepth(10002).setScrollFactor(0);

                let verifyText = this.add.text(20, 20, 'Synthesizing Vectors...', { 
                    fontSize: '14px', fill: '#00ffff', fontFamily: 'Courier New'
                }).setDepth(10003).setScrollFactor(0).setAlpha(0);

                // 3. The 5-Second Minimum Timer
                let minTimePassed = false;
                this.time.delayedCall(5000, () => {
                    minTimePassed = true;
                });

                // 4. Movement Tween (The 8-second glide)
                this.tweens.add({
                    targets: man,
                    x: 800,
                    duration: 8000,
                    ease: 'Linear'
                });

                // 5. The "Gatekeeper" Loop
                // This runs every 100ms to see if we are allowed to start the game
                let startCheck = this.time.addEvent({
                    delay: 100,
                    callback: () => {
                        const animsReady = Object.keys(this.anims.anims.entries).length > 0;

                        // Conditions: 5s passed AND animations are ready
                        if (minTimePassed && animsReady) {
                            startCheck.remove(); // Stop checking
                            verifyText.destroy();
                            
                            // Trigger the fade out and transition
                            this.cameras.main.fadeOut(1000, 0, 0, 0);
                            this.time.delayedCall(1000, () => {
                                loadBG.destroy();
                                man.destroy();
                                loadText.destroy();
                                this.gameStarted = true;
                                this.physics.resume();
                                this.cameras.main.fadeIn(1000, 0, 0, 0);
                            });
                        } else if (minTimePassed && !animsReady) {
                            // Timer is done but GPU is still busy; show the text
                            verifyText.setAlpha(1);
                        }
                    },
                    loop: true
                });
            });

            // // 11. START SCREEN
            // this.startBG = this.add.sprite(400, 225, 'startScreen_01').setDepth(10000).setScrollFactor(0);
            // // this.startBG.play('start_anim');

            // this.startPrompt = this.add.text(400, 400, 'PRESS SPACE TO START OPTIMIZING TITER', {
            //     fontSize: '20px', fill: '#ffffff', backgroundColor: '#000'
            // }).setOrigin(0.5).setDepth(10001).setScrollFactor(0);

            // // Stop physics until started
            // this.physics.pause();

            // this.input.keyboard.once('keydown-SPACE', () => {
            //     this.startBG.destroy();
            //     this.startPrompt.destroy();

            //     // 1. Setup Loading Assets
            //     let loadBG = this.add.image(400, 225, 'load_BG01_01').setScrollFactor(0).setDepth(10000);
                
            //     // Man starts 25px further right (825) and slides to edge (800)
            //     let man = this.add.image(825, 225, 'load_FG01_01').setOrigin(1, 0.5).setScrollFactor(0).setDepth(10001);
            //     let loadingText = this.add.text(40, 40, 'Loading Research Data...', { fill: '#ffffff' }).setDepth(10001);
            //     this.load.on('progress', (value) => {
            //         // value is 0 to 1. Use it to scale a bar or update text.
            //         loadingText.setText(`Loading: ${Math.round(value * 100)}%`);
            //     });
                
            //     let loadText = this.add.text(40, 380, 'Press or Hold \n[SPACE] to\nshoot & collect full capsids', {
            //         fontSize: '18px',
            //         fill: '#ffffff',
            //         fontFamily: 'Courier New',
            //     }).setDepth(10002).setScrollFactor(0); 

            //     this.load.on('complete', () => {
            //         loadingText.destroy();
            //         console.log("Assets 100% loaded and decoded.");
            //     });

            //     // 2. The 8-Second Glide
            //     this.tweens.add({
            //         targets: man,
            //         x: 800,
            //         duration: 8000,
            //         ease: 'Linear',
            //         onComplete: () => {
            //             // Clean up assets after fade is black
            //             loadBG.destroy();
            //             man.destroy();
            //             loadText.destroy();
                         
            //             // 4. Start the Game
            //             this.gameStarted = true;
            //             this.physics.resume();
            //             this.cameras.main.fadeIn(1000, 0, 0, 0);
            //         }
            //     });

            //     // 3. The Overlapping Fade-Out
            //     // Starts at 4 seconds (4000ms) to create a smooth transition while he is still moving
            //     this.time.delayedCall(4000, () => {
            //         this.cameras.main.fadeOut(1000, 0, 0, 0);
            //     });
            // });

            const contaminationDamage = 2;


            /////////
            
            // --- DECOR & BACKGROUND ---
            // SECTION A: MAIN PATH
            // Starts at 0, ends at the boss room entrance
            this.add.tileSprite(0, mainFloorY, bossRoomShift, 350, 'BasementTile')
                .setOrigin(0, 0)
                .setDepth(-10);

            // SECTION B: BOSS ROOM 
            // Starts at bossRoomShift, positioned lower to stay beneath the boss floor
            this.add.tileSprite(bossRoomShift, bossFloorY, 800, 350, 'BasementTile')
                .setOrigin(0, 0)
                .setDepth(-10);


            // ---DEBUG CLICK GUIDE --- 
            // this.input.on('pointerdown', (pointer) => {
            //     if (!this.debugActive) return;
            //     let wx = pointer.worldX;
            //     let wy = pointer.worldY;
                
            //     // Fallback to 0 if variables aren't defined yet
            //     let s1 = this.section1Shift || 2000;
            //     let s2 = this.section2Shift || 4000;
            //     let s3 = this.section3Shift || 6000;
            //     let s4 = this.section4Shift || 8000;
            //     let brs = this.bossRoomShift || 10000;

            //     let currentOffset = 0;
            //     let sectionName = "Sec 0";

            //     if (wx >= brs) { currentOffset = brs; sectionName = "Boss"; }
            //     else if (wx >= s4) { currentOffset = s4; sectionName = "Sec 4"; }
            //     else if (wx >= s3) { currentOffset = s3; sectionName = "Sec 3"; }
            //     else if (wx >= s2) { currentOffset = s2; sectionName = "Sec 2"; }
            //     else if (wx >= s1) { currentOffset = s1; sectionName = "Sec 1"; }

            //     let localX = Math.floor(wx - currentOffset);
            //     console.log(`--- [${sectionName}] Offset: sectionShift + ${localX}, Y: ${Math.floor(wy)} ---`);
            // });
        }

        function update(time) {
            // --- 0. DEBUG TOGGLES ---
            if (Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey('Y'))) {
                if (this.player.x < 200) {
                    this.debugActive = true; 
                    this.createDebugTools(); 
                    console.log("Debug Mode Activated");
                }
            }
            
            // --- 1. PAUSE TOGGLE (PRIORITY 1) ---
            if (Phaser.Input.Keyboard.JustDown(this.enterKey)) {
                if (!this.isPaused) {
                    triggerPause(this); 
                } else {
                    resumeGame(this);
                }
            }

            // --- 2. HARD PAUSE CHECK ---
            // If VirusGEN + Stabilizer is active, we freeze the entire loop here.
            if (this.isPaused && this.hardPauseActive) {
                return; 
            }

            // --- 4. PLAYER CONTROLS ---
            // We block input if controls are disabled OR if the "Fake Pause" modal is up.
            if (this.controlsEnabled && cursors && !this.isPaused) {
                
                // MOVEMENT
                let currentMaxSpeed = this.speedLimited ? 125 : 200;
                if (cursors.left.isDown) {
                    player.body.setVelocityX(-currentMaxSpeed);
                    player.anims.play('walk', true);
                    player.setFlipX(true);
                } else if (cursors.right.isDown) {
                    player.body.setVelocityX(currentMaxSpeed);
                    player.anims.play('walk', true);
                    player.setFlipX(false);
                } else {
                    player.body.setVelocityX(0);
                    if (player.anims.currentAnim && player.anims.currentAnim.key !== 'throw') {
                        player.anims.play('idle');
                    }
                }

                // JUMPING
                let isGrounded = player.body.blocked.down || player.body.touching.down;
                let jumpJustPressed = Phaser.Input.Keyboard.JustDown(cursors.up);
                let overlappingCapsid = capsids.getChildren().some(capsid => {
                    return Phaser.Geom.Intersects.RectangleToRectangle(player.getBounds(), capsid.getBounds());
                });

                if (jumpJustPressed && isGrounded && !overlappingCapsid) {
                    player.body.setVelocityY(-450);
                }

                // SHOOTING
                if (this.currentWeapon !== null) {
                    let stats = this.weaponStats[this.currentWeapon]; 
                    let actualFireRate = this.revITActive ? stats.fireRate / 2 : stats.fireRate;

                    if (this.fireKey.isDown && time > this.lastFired) {
                        player.anims.play('throw', true);
                        throwTube(this); 
                        this.lastFired = time + actualFireRate;
                    }
                }
            } else {
                // Stop player if paused or disabled
                if (player && player.body) {
                    player.body.setVelocityX(0);
                    player.anims.play('idle');
                }
            }

            // --- 5. WORLD LOGIC (Continues during "Fake Pause") ---
            
            // Projectile Cleanup
            tubes.getChildren().forEach(tube => {
                if (tube.x > this.cameras.main.scrollX + 1000 || tube.x < this.cameras.main.scrollX - 200) {
                    tube.destroy();
                }
            });

            // Capsid Bobbing
            if (!this.stabilizerActive) {
                capsids.getChildren().forEach(capsid => {
                    // Normal floating
                    capsid.y = capsid.baseY + Math.sin(time * 0.003) * 30;
                });
            } else {
                capsids.getChildren().forEach(capsid => {
                    // Snap to lowest point (baseY + amplitude)
                    // 30 is your amplitude from the line above
                    if (capsid.y !== capsid.baseY + 30) {
                        capsid.y = capsid.baseY + 30;
                    }
                });
            }

            // Shear Trap Animation
            this.trapList.forEach(t => {
                t.beam.tilePositionY -= (this.trapState === 'active') ? 15 : 2;
            });

            // Platforms
            this.movingPlatform.getChildren().forEach(platform => {
                if (!this.stabilizerActive) {
                    platform.x += platform.speed * platform.direction;
                    if (platform.x >= platform.startX + platform.range) platform.direction = -1;
                    if (platform.x <= platform.startX) platform.direction = 1;

                    if (player.body.touching.down && Phaser.Geom.Intersects.RectangleToRectangle(player.getBounds(), platform.getBounds())) {
                        player.x += platform.speed * platform.direction;
                    }
                }
            });

            // Regulatory NPC Sync
            if (this.regFollowing && this.regulatoryNPC) {
                const stopPoint = this.bossRoomShift - 200;
                const targetX = this.player.x - 64; 

                if (this.activeRegText && this.activeRegText.active) {
                    this.activeRegText.x = this.regulatoryNPC.x;
                    this.activeRegText.y = this.regulatoryNPC.y - 130;
                }

                if (this.regulatoryNPC.x < stopPoint) {
                    this.regulatoryNPC.body.setVelocityX(this.player.body.velocity.x);
                    if (this.regulatoryNPC.x < targetX - 10) {
                        this.regulatoryNPC.body.setVelocityX(this.player.body.velocity.x + 150);
                    }
                    this.regulatoryNPC.play('reg_walk', Math.abs(this.regulatoryNPC.body.velocity.x) > 0.1);
                } else {
                    this.regFollowing = false;
                    this.regulatoryNPC.body.setVelocityX(0);
                    this.regulatoryNPC.anims.stop();
                    this.regulatoryNPC.setFrame(2);
                    if (this.activeRegText) { this.activeRegText.destroy(); this.activeRegText = null; }
                }
            }

            // // MARQUEE TRIGGER
            // let marqDist = Math.abs(this.player.x - bossRoomShift);
            // if marqDist < 600) {
            //     if (!this.bossMarquee)
            // }

            // Boss Trigger
            let dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
            if (dist < 800 && !this.bossStarted) { 
                this.bossStarted = true; 
                startBossLogic(this);
            }

            // Debug Tools
            if (Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B))) {
                this.health = 100;    // Scene-level health
                totalScore = 1.25e14; // Global-level score
                
                console.log("DEBUG B: Health set to " + this.health + ", Score set to " + totalScore);
                
                bossHP = 0; 
                endGame(this); 
            }

            // BOSS SECTION CAMERA TRIGGER
            if (this.player.x > this.bossRoomShift - 100 && this.player.y > 435 && !this.bossCameraLocked) {
                this.bossCameraLocked = true;
                this.cameras.main.stopFollow();

                // Using 'this.' to access the now-global variables
                let centerX = (this.bossRoomShift + this.bossRoomEnd) / 2;
                let centerY = this.bossFloorY - 200; 

                this.cameras.main.pan(centerX, centerY, 1000, 'Power2');

                this.time.delayedCall(1000, () => {
                    startBossLogic(this);
                });
            }
        }

        function setupContaminationHazard(scene, hazardX, hazardY, genX, genY, damageScale, playerObj, projectileGroup) {
    
            // 1. HAZARD GROUP (Smog + HVAC)
            let hvac = scene.add.image(hazardX + 172, hazardY, 'hvac').setOrigin(0.5, 1).setScale(0.75);
            let smog = scene.add.tileSprite(hazardX, hazardY, 300, 32, 'smog01').setOrigin(0.5, 1).setDepth(-1);
            scene.physics.add.existing(smog, true);
            
            let particles = scene.add.particles(0, 0, 'skull', {
                x: { min: -150, max: 150 },
                y: { min: -50, max: 0 },
                quantity: 1,
                frequency: 1000,
                lifespan: 3000,
                speedY: { min: -20, max: -10 },
                scale: { start: 0, end: 1.75 },
                alpha: { start: 0.6, end: 0 },
            });
            particles.setPosition(hazardX, hazardY);

            // 2. CONTROL GROUP (Generator)
            // CREATE GEN FIRST so we can reference its depth
            let gen = scene.physics.add.staticSprite(genX, genY, 'generator', 0);

            // NOW CREATE BACKDROP
            let genBackdrop = scene.add.graphics();
            genBackdrop.fillStyle(0x000000, 0.4); 
            genBackdrop.fillCircle(genX, genY - 20, 60); 
            genBackdrop.setDepth(gen.depth - 1); 

            // Pulse the backdrop to simulate light flicker
            scene.tweens.add({
                targets: genBackdrop,
                alpha: 0.2,
                duration: 100,
                yoyo: true,
                repeat: -1,
                repeatDelay: () => Math.random() * 500
            });

            // SPARKS
            let sparks = scene.add.particles(0, 0, 'poof', {
                x: genX,
                y: genY - 25,
                frame: [0, 1, 2, 3, 4, 5, 6],
                speed: { min: -180, max: 180 },
                angle: { min: 0, max: 360 },
                scale: { start: 0.8, end: 0 }, 
                color: [ 0xff00ff, 0xffffff, 0x00ffff ], 
                blendMode: 'ADD',
                lifespan: 600,
                frequency: 80, 
                gravityY: 400,
                quantity: 2 
            }).setDepth(gen.depth + 1);

            // 3. COSMETIC: SMOG ANIMATION
            scene.tweens.add({
                targets: smog,
                tilePositionX: 500,
                y: hazardY - 5,
                duration: 3000,
                yoyo: true,
                repeat: -1
            });

            // 4. RESOLUTION LOGIC
            if (projectileGroup) {
                scene.physics.add.overlap(projectileGroup, gen, (genObj, tube) => {
                    if (genObj.frame.name === 1) return; 
                    
                    genObj.setFrame(1); 
                    scene.add.sprite(tube.x, tube.y, 'poof').play('impact_poof').setDepth(3000);
                    tube.destroy();
                    
                    particles.stop();
                    sparks.stop();

                    // NEW: Stop the NPC from throwing
                    if (scene.npcThrowTimer) {
                        scene.npcThrowTimer.remove(); 
                    }

                    // Optional: Force NPC back to idle frame
                    if (scene.cdmoNPC) {
                        scene.cdmoNPC.anims.stop();
                        scene.cdmoNPC.setFrame(0); 
                    }

                    // Kill backdrop
                    scene.tweens.add({
                        targets: genBackdrop,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => genBackdrop.destroy()
                    });

                    smog.body.enable = false;
                    scene.tweens.add({
                        targets: smog,
                        alpha: 0,
                        scaleY: 0,
                        duration: 500,
                        onComplete: () => { if (smog.active) smog.destroy(); }
                    });
                });
            }

            // 5. DAMAGE LOGIC
            if (playerObj) {
                scene.physics.add.overlap(playerObj, smog, () => {
                    damagePlayer(playerObj, smog, scene, 0.5 * damageScale);
                });
            }
            scene.npcThrowTimer = scene.time.addEvent({
                delay: 3000,
                callback: (targetX, targetY) => {
                    if (!scene.cdmoNPC || !scene.cdmoNPC.active) return;

                    scene.cdmoNPC.play('mirus_throw');

                    let spaceText = scene.add.text(scene.cdmoNPC.x, 400, 'SPACE', {
                        fontSize: '24px',
                        fontFamily: 'Courier New',
                        color: '#ffffff',
                        fontWeight: 'bold'
                    }).setOrigin(0.5);

                    // Add the black shadow
                    spaceText.setShadow(2, 2, '#000000', 2, true, true);

                    // 3. TEXT TWEEN (Float and Fade)
                    scene.tweens.add({
                        targets: spaceText,
                        y: 430, // Drifts
                        alpha: 0,
                        duration: 1000,
                        onComplete: () => spaceText.destroy()
                    });

                    scene.time.delayedCall(400, () => {
                        let tube = scene.physics.add.sprite(scene.cdmoNPC.x, scene.cdmoNPC.y - 40, 'tubeP');
                        tube.setTint(0x808080);
                        tube.setDepth(5);

                        const missOffset = (Math.random() > 0.5 ? 1 : -1) * 60;
                        const dist = (targetX + missOffset) - scene.cdmoNPC.x;

                        tube.body.setVelocityX(dist);
                        tube.body.setVelocityY(-600);
                        tube.body.setGravityY(600);

                        scene.time.delayedCall(2000, () => { if (tube.active) tube.destroy(); });
                    });
                },
                args: [genX, genY],
                callbackScope: scene,
                loop: true
            });
        }

        function typeSequentialVignette(scene, x, y, lines, followTarget = null) {
            let index = 0;

            // Create the base text object
            let txt = scene.add.text(x, y, '', {
                fontSize: '18px',
                fill: '#ffffff',
                wordWrap: { width: 320 },
                fontFamily: 'Courier New',
                stroke: '#000000',
                strokeThickness: 4,
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(1000);
            txt.setShadow(2, 2, 'rgba(0,0,0,0.5)', 6);

            // if (!followTarget) {
            //     // 1. Calculate the offset based on where the camera is right now
            //     let cameraX = scene.cameras.main.scrollX;
            //     let relativeX = (x - cameraX) / 0.78; 
                
            //     // 2. Set the position so it appears exactly at 'x' despite the factor
            //     txt.x = relativeX;
            //     txt.setScrollFactor(0.78);
                
            //     scene.tweens.add({
            //         targets: txt,
            //         y: '-=10',
            //         duration: 2000,
            //         yoyo: true,
            //         repeat: -1,
            //         ease: 'Sine.easeInOut'
            //     });
            // }

            // Follow Logic: Tether to NPC if followTarget exists
            const updatePosition = () => {
                if (txt.active && followTarget) {
                    txt.x = followTarget.x;
                    txt.y = followTarget.y - 130;
                }
            };
            if (followTarget) scene.events.on('update', updatePosition);

            // Typewriter Mechanic
            const typeEffect = (targetLine) => {
                let i = 0;
                txt.setText('');
                
                const timer = scene.time.addEvent({
                    delay: 30, // 30ms per character
                    repeat: targetLine.length - 1,
                    callback: () => {
                        if (txt.active) {
                            txt.text += targetLine[i];
                            i++;
                        }
                        // Once finished typing, wait 2.5 seconds then move to next line
                        if (i === targetLine.length) {
                            scene.time.delayedCall(2500, showNextLine);
                        }
                    }
                });
            };

            const showNextLine = () => {
                index++;
                if (index < lines.length) {
                    typeEffect(lines[index]);
                } else {
                    // Outro Tween
                    scene.tweens.add({
                        targets: txt,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => {
                            txt.destroy();
                            if (followTarget) scene.events.off('update', updatePosition);
                        }
                    });
                }
            };

            // Start the first line
            typeEffect(lines[index]);
        }

        function addDialogueTrigger(scene, x, y, width, height, callback) {
            let trigger = scene.add.zone(x, y, width, height);
            scene.physics.add.existing(trigger, true);
            scene.physics.add.overlap(player, trigger, () => {
                callback();
                trigger.destroy();
            }, null, scene);
        }


        function startBlockingDialogue(scene, message, onComplete = null) {
            scene.controlsEnabled = false;
            player.setVelocityX(0);
            player.anims.play('idle');

            let modal = scene.add.container(500, 175).setScrollFactor(0).setDepth(2000);
            let portrait = scene.add.image(150, 0, 'labmatePortrait').setScale(1).setDepth(2001);
            let mouth = scene.add.sprite(132, 26, 'labmateMouth').setScale(1).setDepth(2002);
            mouth.play('mouthloop');
            
            // 2. Speech Bubble shifted left (-350 to center it under the text area)
            let speechBubble = scene.add.graphics();
            speechBubble.fillStyle(0x000000, 0.85).fillRoundedRect(-350, -80, 450, 180, 10);

            // 3. Text Object shifted left (-330)
            let txt = scene.add.text(-330, -60, '', { 
                fontSize: '18px', 
                fill: '#ffffff', 
                wordWrap: { width: 400 }, 
                fontFamily: 'Courier New'
            });

            modal.add([speechBubble, portrait, mouth, txt]);

            let i = 0;
            scene.time.addEvent({
                delay: 30,
                callback: () => {
                    txt.text += message[i];
                    i++;
                    if (i === message.length) {
                        // Prompt moved to align with the left-justified text
                        let prompt = scene.add.text(-125, 75, '[ SPACE ]', { 
                            fontSize: '14px', 
                            fill: '#00ff00' 
                        }).setOrigin(0.5);
                        modal.add(prompt);
                        
                        scene.input.keyboard.once('keydown-SPACE', () => {
                            modal.destroy();
                            scene.controlsEnabled = true;
                            if (onComplete) onComplete();
                        });
                    }
                },
                repeat: message.length - 1
            });
        }

        function startPassiveVignette(scene, x, y, message, textureKey, animKey, bgKey) {
            // Container at your specified center point (1150, 200)
            let bubble = scene.add.container(x, y).setDepth(10);

            // 1. Background (400x96) - Native scale
            let bg = scene.add.image(0, 0, bgKey);
            
            // 2. Animated Portrait (64x64) 
            // Positioned 150px to the right of center to stay inside the 400px BG
            let portrait = scene.add.sprite(150, 0, textureKey);
            portrait.play(animKey);
            
            // 3. Text 
            // Positioned to the left of the portrait
            let txt = scene.add.text(-40, 0, message, {
                fontSize: '16px',
                fill: '#ffffff',
                align: 'left',
                wordWrap: { width: 280 },
                fontFamily: 'Courier New',
                stroke: '#000000',
                strokeThickness: 5
            }).setOrigin(0.5);

            bubble.add([bg, portrait, txt]);

            // Mechanical animation: Subtle hang time then fade
            scene.tweens.add({
                targets: bubble,
                alpha: { from: 1, to: 0 },
                delay: 5000, // Remains solid for 5 seconds while player walks past
                duration: 1000,
                onComplete: () => bubble.destroy()
            });
        }
        function mirusShoot(scene) {
            if (!scene.mirusFAS1) return;

            // Remove any old listeners to prevent double-firing
            scene.mirusFAS1.off('animationupdate');

            scene.mirusFAS1.play('mirus_throw', true);

            // Use specific listener for frame changes
            scene.mirusFAS1.on('animationupdate', function (anim, frame) {
                // frame.index is 1-based in most Phaser versions for the current animation
                // If your start frame is 1 and end is 5, frame 4 is the release point
                if (frame.index === 4) {
                    let p = scene.virusgenProjectiles.create(
                        scene.mirusFAS1.x + 30, 
                        scene.mirusFAS1.y - 45, 
                        'tubeV' 
                    );
                    
                    if (p && p.body) {
                        p.setDepth(100);
                        p.body.setAllowGravity(false);
                        p.setVelocityX(800);
                        
                        scene.time.delayedCall(625, () => {
                            if (p.active) p.destroy();
                        });
                    }
                    // Kill this listener immediately after the shot is fired
                    scene.mirusFAS1.off('animationupdate');
                }
            });
        }
    

        function throwTube(scene) {
            let activeWeapon = scene.currentWeapon;
            if (!activeWeapon) return;
            let stats = scene.weaponStats[activeWeapon];

            // Use scene.revITActive, NOT this.revITActive
            let isRevIT = scene.revITActive; 

            const fire = (yOffset) => {
                let direction = player.flipX ? -1 : 1;
                let offsetX = direction * 50;
                let projectile = tubes.create(player.x + offsetX, player.y, stats.texture);
                
                if (projectile) {
                    projectile.body.setAllowGravity(false);
                    projectile.body.setVelocity(stats.speed * direction, yOffset);
                    projectile.setAngularVelocity(500);

                    if (isRevIT) {
                        if (activeWeapon === 'VirusGEN') projectile.setTint(0xff00ff);
                        if (activeWeapon === 'PolymerF') projectile.setTint(0x888888);
                    }

                    scene.time.delayedCall(2000, () => {
                        if (projectile.active) projectile.destroy();
                    });
                }
            };

            if (isRevIT) {
                fire(0);    // Straight
                fire(-200); // Angle Up
                fire(200);  // Angle Down
            } else {
                fire(0);
            }
        }

        function createRevIT(scene, x, y) {
            let item = scene.physics.add.staticSprite(x, y, 'item_RevIT').setAlpha(0.3);
            scene.revITItems.add(item); // Add to group
            
            scene.physics.add.overlap(scene.player, item, () => {
                if (scene.currentWeapon !== 'VirusGEN' || scene.revITActive || item.alpha < 1) return;
                scene.revITActive = true;
                item.setAlpha(0.1);
                scene.time.delayedCall(6000, () => { scene.revITActive = false; });
                scene.time.delayedCall(10000, () => {
                    item.setAlpha(scene.currentWeapon === 'VirusGEN' ? 1 : 0.3);
                });
            });
            return item;
        }

        function createStabilizer(scene, x, y) {
            let item = scene.physics.add.staticSprite(x, y, 'item_Stabilizer').setAlpha(0.3);
            scene.stabilizerItems.add(item); // Add to group

            scene.physics.add.overlap(scene.player, item, () => {
                if (scene.currentWeapon !== 'VirusGEN' || scene.stabilizerActive || item.alpha < 1) return;
                scene.stabilizerActive = true;
                item.setAlpha(0.1);
                scene.capsids.getChildren().forEach(c => c.setTint(0x00ffff));
                scene.time.delayedCall(6000, () => {
                    scene.stabilizerActive = false;
                    scene.capsids.getChildren().forEach(c => c.clearTint());
                });
                scene.time.delayedCall(10000, () => {
                    item.setAlpha(scene.currentWeapon === 'VirusGEN' ? 1 : 0.3);
                });
            });
            return item;
        }

        function hitCapsid(tube, capsid) {
            // 1. Get the scene from the tube itself
            let scene = tube.scene; 
            let stats = weaponStats[currentWeapon];

            if (scene.anims.exists('impact_poof')) {
                let p = scene.add.sprite(tube.x, tube.y, 'poof');
                p.setDepth(1000); // Above the gameplay
                p.setAngle(Phaser.Math.Between(0, 360)); // Randomized rotation
                p.play('impact_poof');
                // No need to manually destroy if 'hideOnComplete: true' was set in the anim
                p.on('animationcomplete', () => { 
                    p.destroy();
                });
            }

            capsid.hp -= stats.damage;
            capsid.setTint(0xff00ff); 

            // Use scene.time instead of this.time
            scene.time.delayedCall(100, () => {
                if (capsid.active) capsid.clearTint();
            });

            tube.destroy(); 

            if (capsid.hp <= 0) {
                // 2. Use scene.score instead of this.score
                scene.score += 1;
                scene.scoreText.setText('CAPSIDS CAPTURED: ' + scene.score);
                
                captureSequence(capsid);
            }
        }
        
        function captureSequence(target) {
            console.log("Target successfully captured!");
            target.destroy();
            // Later: You can trigger a "sparkle" or "collect" animation here!
            totalScore += 1;
        }
        function createPlatform(scene, platformsGroup, x, y, widthInTiles) {
            // 1. Create the Left Edge (Frame 0)
            platformsGroup.create(x, y, 'platform02tiles', 0);
            // 2. Create the Middle Sections (Frame 1)
            // We loop through the middle (starting at index 1, ending before the last tile)
            for (let i = 1; i < widthInTiles - 1; i++) {
                platformsGroup.create(x + (i * 64), y, 'platform02tiles', 1);
            }
            // 3. Create the Right Edge (Frame 2)
            platformsGroup.create(x + ((widthInTiles - 1) * 64), y, 'platform02tiles', 2);
        }

        function triggerPause(scene) {
            scene.isPaused = true;
            
            // Check section property and specific weapon string
            let inSection1 = (scene.player.x < scene.section1Shift);
            let stableGen = (scene.currentWeapon === 'VirusGEN' && scene.stabilizerActive);

            scene.hardPauseActive = (inSection1 || stableGen);

            if (scene.hardPauseActive) {
                scene.physics.pause();
                if (scene.gameTimer) scene.gameTimer.paused = true;
            }

            // UI Container
            scene.pauseModal = scene.add.container(400, 225).setDepth(10000).setScrollFactor(0);
            let bg = scene.add.rectangle(0, 0, 360, 160, 0x000000, 0.9).setStrokeStyle(2, 0xffffff);
            
            let header = scene.hardPauseActive ? "SYSTEM PAUSED" : "UNSTABLE WINDOW";
            let body = scene.hardPauseActive ? "Process parameters locked." : "You cannot pause your transfection complex delivery window without VirusGEN Stabilizer";
            
            let titleText = scene.add.text(0, -40, header, { fontSize: '22px', fill: '#00ffff', fontStyle: 'bold' }).setOrigin(0.5);
            let descText = scene.add.text(0, 10, body, { fontSize: '13px', fill: '#ffffff', align: 'center', wordWrap: { width: 320 } }).setOrigin(0.5);
            
            let btnCont = scene.add.text(0, 45, "  CONTINUE  ", { fontSize: '18px', fill: '#00ff00' }).setOrigin(0.5).setInteractive();
            let btnReset = scene.add.text(0, 65, "  START OVER ", { fontSize: '18px', fill: '#ffffff' }).setOrigin(0.5).setInteractive();
            
            scene.pauseModal.add([bg, titleText, descText, btnCont, btnReset]);

            // Keyboard Logic
            let selectedIndex = 0; 
            const updateVisuals = () => {
                btnCont.setText(selectedIndex === 0 ? "> CONTINUE <" : "  CONTINUE  ");
                btnCont.setFill(selectedIndex === 0 ? "#00ff00" : "#ffffff");
                btnReset.setText(selectedIndex === 1 ? "> START OVER <" : "  START OVER ");
                btnReset.setFill(selectedIndex === 1 ? "#00ff00" : "#ffffff");
            };
            updateVisuals();

            scene.pauseListener = (event) => {
                if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.UP) {
                    selectedIndex = 0;
                    updateVisuals();
                } else if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.DOWN) {
                    selectedIndex = 1;
                    updateVisuals();
                } else if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.ENTER || event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) {
                    scene.input.keyboard.off('keydown', scene.pauseListener);
                    if (selectedIndex === 0) resumeGame(scene);
                    else window.location.reload();
                }
            };
            scene.input.keyboard.on('keydown', scene.pauseListener);
        }

        function resumeGame(scene) {
            scene.isPaused = false;
            scene.hardPauseActive = false;
            scene.physics.resume();
            if (scene.gameTimer) scene.gameTimer.paused = false;
            if (scene.pauseModal) scene.pauseModal.destroy();
            // Ensure input listener is removed if closed via Enter toggle
            scene.input.keyboard.off('keydown', scene.pauseInputListener);
        }

        function createVerticalWall(scene, x, yStart, numMiddleSegments, group) {
            // 1. Top Cap (Frame 2)
            let top = group.create(x, yStart, 'verticalWall', 2);
            
            // 2. Middle Segments (Frame 1)
            for (let i = 1; i <= numMiddleSegments; i++) {
                group.create(x, yStart + (i * 64), 'verticalWall', 1);
            }
            
            // 3. Bottom Cap (Frame 0)
            let bottomY = yStart + ((numMiddleSegments + 1) * 64);
            let bottom = group.create(x, bottomY, 'verticalWall', 0);
            
            return { top, bottom, bottomY }; // Returns data in case we need to know the wall's end point
        }
        
        function damagePlayer(player, hazard, scene, amount) {
            if (!scene) return;
            scene.health -= amount;
            if (scene.healthText) {
                // Keeps it clean: No negatives, no decimals
                let displayHealth = Math.max(0, Math.floor(scene.health));
                scene.healthText.setText('HEALTH: ' + displayHealth + '%');
            }
            player.setTint(0xff0000);
            scene.time.delayedCall(100, () => {
                if (player) player.clearTint();
            });

            if (scene.health <= 0) {
                scene.physics.pause();
                scene.controlsEnabled = false; // Stop player input
                
                let gameOver = scene.add.text(400, 300, 'TITER LOSS DETECTED\nGAME OVER', { 
                    fontSize: '48px', 
                    fill: '#ff0000', 
                    align: 'center', 
                    backgroundColor: '#000',
                    padding: { x: 20, y: 20 }
                });
                let subText = scene.add.text(400, 350, 'Too Difficult? Ask Your Table Host About a Secondary Task', { 
                    fontSize: '16px', 
                    fill: '#ffffff', 
                    align: 'center', 
                    fontFamily: 'Courier New',
                    backgroundColor: '#000'
                });
                gameOver.setOrigin(0.5).setScrollFactor(0).setDepth(3000);
                
                setTimeout(() => { window.location.reload(); }, 3000);
            }
        }

        function spawnLabmate(scene, x, y, flip = false) {
            // Create the sprite
            let lm = scene.add.sprite(x, y, 'labmateIdle');
            
            // Mechanics: Anchor to feet, set depth behind player/boss but in front of BG
            lm.setOrigin(0.5, 1);
            lm.setDepth(15);
            lm.flipX = flip;

            // Play the pre-defined idle animation
            lm.play('labmate_idle_anim');

            return lm;
        }

        function collectNotebookP(scene) {
            // 1. Enter "Cutscene Mode"
            scene.controlsEnabled = false;
            player.setVelocity(0, 0);
            player.anims.play('idle'); // Make the scientist face forward

            // 2. Clear the world item
            if (scene.notebook1) scene.notebook1.destroy();

            // 3. Create UI Elements (All set to Depth 3000+)
            let largeNote = scene.add.image(400, 225, 'large_notebook').setScrollFactor(0).setDepth(3001);
            let card = scene.add.image(400, 250, 'notebookPP').setScrollFactor(0).setDepth(3002);
            let btn = scene.add.sprite(400, 350, 'transSelectButton', 1).setScrollFactor(0).setDepth(3003);

            // 4. The Selection Logic
            // We use a slight delay before listening to SPACE so the player 
            // doesn't accidentally skip this screen from the previous conversation.
            scene.time.delayedCall(300, () => {
                scene.input.keyboard.once('keydown-SPACE', () => {
                    btn.setFrame(2); // Show "Clicked" state

                    scene.time.delayedCall(200, () => {
                        // CLEANUP
                        largeNote.destroy();
                        card.destroy();
                        btn.destroy();

                        startFinalIntroDialogue(scene);
                    });
                });
            });
            scene.currentWeapon = ('PolymerP');
        }

        function collectNotebookF(scene) {
            // 1. Enter "Cutscene Mode"
            scene.controlsEnabled = false;
            player.setVelocity(0, 0);
            player.anims.play('idle');

            // 2. Clear the world item
            if (scene.notebook2) scene.notebook2.destroy();

            // 3. Create UI Elements (All set to Depth 3000+)
            //let largeNoteL = scene.add.image(200, 225, 'large_notebook').setScrollFactor(0).setDepth(3001);
            let largeNoteC = scene.add.image(400, 225, 'large_notebook').setScrollFactor(0).setDepth(3001);
            let cardL = scene.add.image(250, 250, 'notebookPP').setScrollFactor(0).setDepth(3002);
            let btnL = scene.add.sprite(250, 350, 'transSelectButton', 0).setScrollFactor(0).setDepth(3003);
            //let largeNoteR = scene.add.image(600, 225, 'large_notebook').setScrollFactor(0).setDepth(3001);
            let cardR = scene.add.image(550, 250, 'notebookPF').setScrollFactor(0).setDepth(3002);
            let btnR = scene.add.sprite(550, 350, 'transSelectButton', 1).setScrollFactor(0).setDepth(3003);
            let selection = 1; // Default to right

            const cursors = scene.input.keyboard.createCursorKeys();

            const updateHighlight = () => {
                if (selection === 0) {
                    btnL.setFrame(1); // Highlighted frame
                    btnR.setFrame(0); // Normal frame
                } else {
                    btnL.setFrame(0);
                    btnR.setFrame(1);
                }
            };
            // Listen for Left/Right presses
            const keyL = scene.input.keyboard.on('keydown-LEFT', () => {
                selection = 0;
                updateHighlight();
            });
            const keyR = scene.input.keyboard.on('keydown-RIGHT', () => {
                selection = 1;
                updateHighlight();
            });

            // 3. Selection Logic (Space Bar)
            scene.time.delayedCall(300, () => {
                scene.input.keyboard.once('keydown-SPACE', () => {
                    // Turn off the arrow listeners so they don't fire later
                    scene.input.keyboard.off('keydown-LEFT');
                    scene.input.keyboard.off('keydown-RIGHT');

                    // Show "Clicked" state on the chosen button
                    let chosenBtn = (selection === 0) ? btnL : btnR;
                    chosenBtn.setFrame(2);

                    scene.time.delayedCall(200, () => {
                        // Set the actual weapon stats based on selection
                        scene.currentWeapon = (selection === 0) ? 'PolymerP' : 'PolymerF';

                        // Update the Tool HUD to reflect the choice
                        if (scene.toolUI) {
                            scene.toolUI.setVisible(true);
                            // If PolymerP is frame 1 and PolymerF is frame 2:
                            scene.reagentDisplay.setFrame(selection === 0 ? 1 : 2);
                        }

                        console.log("Weapon Equipped:", scene.currentWeapon);
                        
                        // Cleanup
                        //largeNoteR.destroy(); largeNoteL.destroy();
                        largeNoteC.destroy();
                        cardL.destroy(); cardR.destroy();
                        btnL.destroy(); btnR.destroy();

                    });
                    scene.input.keyboard.removeAllListeners();
                    scene.controlsEnabled = true; 
    
                    // 3. IMPORTANT: Update the HUD frame immediately
                    if (currentWeapon === 'PolymerP') scene.reagentDisplay.setFrame(1);
                    if (currentWeapon === 'PolymerF') scene.reagentDisplay.setFrame(2);

                    console.log("Controls restored. Weapon set to:", scene.currentWeapon);
                });
            });
        }

        function collectNotebookV(scene) {
            scene.controlsEnabled = false;
            player.setVelocity(0, 0);
            player.anims.play('idle');

            if (scene.notebook3) {
                scene.notebook3.destroy();
                scene.notebook3 = null;
            }

            // Use scene.currentWeapon to match your create() initialization
            let currentLeftTexture = (scene.currentWeapon === 'PolymerP') ? 'notebookPP' : 'notebookPF';

            let largeNoteC = scene.add.image(400, 225, 'large_notebook').setScrollFactor(0).setDepth(3001);
            let cardL = scene.add.image(250, 250, currentLeftTexture).setScrollFactor(0).setDepth(3002);
            let btnL = scene.add.sprite(250, 350, 'transSelectButton', 0).setScrollFactor(0).setDepth(3003);
            let cardR = scene.add.image(550, 250, 'notebookVG').setScrollFactor(0).setDepth(3002);
            let btnR = scene.add.sprite(550, 350, 'transSelectButton', 1).setScrollFactor(0).setDepth(3003);
            
            let selection = 1;

            // Use temporary listeners
            const keyL = scene.input.keyboard.on('keydown-LEFT', () => { selection = 0; btnL.setFrame(1); btnR.setFrame(0); });
            const keyR = scene.input.keyboard.on('keydown-RIGHT', () => { selection = 1; btnL.setFrame(0); btnR.setFrame(1); });

            scene.input.keyboard.once('keydown-SPACE', () => {
                // Cleanup listeners immediately
                scene.input.keyboard.off('keydown-LEFT');
                scene.input.keyboard.off('keydown-RIGHT');
                
                let chosenBtn = (selection === 0) ? btnL : btnR;
                chosenBtn.setFrame(2);

                scene.time.delayedCall(200, () => {
                    // LOCK IN THE WEAPON (Setting the scene property)
                    if (selection === 1) {
                        scene.currentWeapon = 'VirusGEN';
                        scene.revITItems.getChildren().forEach(item => {
                            item.setAlpha(1);
                        });
                        scene.stabilizerItems.getChildren().forEach(item => {
                            item.setAlpha(1);
                        });
                    }

                    // HUD UPDATE
                    if (scene.reagentDisplay) {
                        scene.toolUI.setVisible(true);
                        let f = 1; // Default
                        if (scene.currentWeapon === 'PolymerF') f = 2;
                        if (scene.currentWeapon === 'VirusGEN') f = 3;
                        scene.reagentDisplay.setFrame(f);
                    }

                    // CLEANUP & RESTORE (All inside the delay)
                    largeNoteC.destroy();
                    cardL.destroy(); btnL.destroy();
                    cardR.destroy(); btnR.destroy();
                    
                    scene.controlsEnabled = true; 
                    console.log("Weapon Finalized: " + scene.currentWeapon);
                });
            });
        }

        function startFinalIntroDialogue(scene) {
            let msg = "Hurry, we need to deliver our transfection complex before the window closes in 15-30 minutes. I'll start a timer for you.";
            let goalMsg = "Goal: Capture full capsids fast to maximize your Titer. If the quality drops or the timer hits zero, the batch is ruined!";

            if (!scene.introModal || !scene.introModal.active) {
                scene.introModal = scene.add.container(400, 225).setScrollFactor(0);
            }
            
            scene.introModal.removeAll(true); 
            scene.introModal.setVisible(true).setDepth(10000); 

            // 1. BASE MODAL (Black Translucent)
            let baseBubble = scene.add.graphics();
            baseBubble.fillStyle(0x000000, 0.85);
            baseBubble.fillRoundedRect(-225, -150, 450, 320, 15);
            baseBubble.lineStyle(2, 0xffffff, 1);
            baseBubble.strokeRoundedRect(-225, -150, 450, 320, 15);
            
            // 2. NARRATIVE TEXT (Small, at the top)
            let txt = scene.add.text(-200, -130, '', { 
                fontSize: '16px', 
                fill: '#ffffff', 
                wordWrap: { width: 400 },
                fontStyle: 'italic'
            });

            scene.introModal.add([baseBubble, txt]);

            let i = 0;
            let typeEvent = scene.time.addEvent({
                delay: 25,
                callback: () => {
                    if (txt && txt.active) {
                        txt.text += msg[i];
                        i++;
                        if (i === msg.length) {
                            // 3. SUB-MODAL (High Contrast Green)
                            let goalBox = scene.add.graphics();
                            goalBox.fillStyle(0x00ff00, 1); // Solid Bright Green
                            goalBox.fillRoundedRect(-200, -50, 400, 160, 10);
                            
                            let goalTxt = scene.add.text(0, 30, goalMsg, { 
                                fontSize: '18px', 
                                fill: '#000000', // Black text for high contrast
                                wordWrap: { width: 360 },
                                fontStyle: 'bold',
                                align: 'center'
                            }).setOrigin(0.5);

                            // 4. PROMPT (Positioned at bottom of base modal)
                            let prompt = scene.add.text(0, 145, '[ Press SPACE ]', { 
                                fontSize: '16px',
                                fill: '#00ff00',
                                fontStyle: 'bold'
                            }).setOrigin(0.5);

                            scene.introModal.add([goalBox, goalTxt, prompt]);
                            
                            scene.input.keyboard.once('keydown-SPACE', () => {
                                scene.introModal.setVisible(false);
                                scene.controlsEnabled = true;
                                scene.challengeStarted = true;

                                // HUD Management
                                scene.scoreText.setVisible(true).setDepth(9999);
                                scene.healthText.setVisible(true).setDepth(9999);
                                scene.timerText.setVisible(true).setDepth(9999);
                                
                                scene.toolUI.setPosition(70, 130).setVisible(true).setScale(0.5);
                                scene.reagentDisplay.setFrame(1);

                                if (scene.door1C) {
                                    scene.tweens.add({
                                        targets: scene.door1C,
                                        y: scene.door1C.y - 80,
                                        duration: 2000
                                    });
                                }
                            });
                        }
                    }
                },
                repeat: msg.length - 1
            });
        }


        function createShearTrap(scene, x, floorY, ceilingY) {
            let floorEmit = scene.add.sprite(x, floorY, 'shearEmitter').setOrigin(0.5, 1).setDepth(31);
            let ceilingEmit = scene.add.sprite(x, ceilingY, 'shearEmitter').setOrigin(0.5, 0).setDepth(31).setFlipY(true);

            let beamHeight = floorY - ceilingY;
            let beam = scene.add.tileSprite(x, ceilingY, 32, beamHeight, 'shearLaser02').setOrigin(0.5, 0).setDepth(30);
            
            // Create the hazard
            let hazard = scene.shearHazards.create(x, ceilingY, null); 
            hazard.setOrigin(0.5, 0);
            
            // FORCE THE BODY SIZE
            // We must set the body size AND the display size to match the beamHeight
            hazard.body.setSize(20, beamHeight); // The 20px width makes it harder to slip through
            hazard.body.setOffset(0, 0);
            
            hazard.setVisible(false);

            let trap = { floorEmit, ceilingEmit, beam, hazard };
            scene.trapList.push(trap);
            return trap;
        }

        function startBossLogic(scene) {
            if (this.bossInitialized) return;
            this.bossInitialized = true;

            // 1. UI Setup (Ensure these are global enough to be accessed)
            let uiX = scene.cameras.main.width / 2;
            scene.add.rectangle(uiX, 50, 400, 20, 0x000000).setScrollFactor(0).setDepth(100);
            bossHealthBar = scene.add.rectangle(uiX, 50, 400, 20, 0xff0000).setScrollFactor(0).setDepth(101);

            const states = ['defensive', 'attacking', 'vulnerable'];
            let currentStateIndex = 0;

            const transition = () => {
                if (bossHP <= 0) return;

                bossState = states[currentStateIndex];
                
                switch (bossState) {
                    case 'defensive':
                        boss.play('boss_defend_anim');
                        scene.time.delayedCall(2000, transition);
                        break;

                    case 'attacking':
                        spawnBossAttack(scene); 
                        scene.time.delayedCall(2000, transition);
                        break;

                    case 'vulnerable':
                        boss.play('boss_vulnerable_anim');
                        scene.time.delayedCall(2000, transition);
                        break;
                }

                currentStateIndex = (currentStateIndex + 1) % states.length;
            };

            transition();
            startPowerupDrops(scene);
        }

        function spawnBossAttack(scene) {
            if (bossHP <= 0) return;

            // Kill any lingering listeners before starting
            boss.off('animationupdate');
            boss.play('boss_attack_anim');

            // Internal tracker to ensure frame 5 and 15 only fire ONCE per animation
            let shot1Fired = false;
            let shot2Fired = false;

            boss.on('animationupdate', (anim, frame) => {
                if (anim.key === 'boss_attack_anim') {
                    if (frame.index === 5 && !shot1Fired) {
                        launchProjectile(scene, boss.y - 60, -250);
                        shot1Fired = true;
                    }
                    if (frame.index === 15 && !shot2Fired) {
                        launchProjectile(scene, boss.y - 120, -250);
                        shot2Fired = true;
                    }
                }
            });

            boss.once('animationcomplete', () => {
                boss.off('animationupdate');
            });
        }

        // SINGLE version of launchProjectile with speed parameter
        function launchProjectile(scene, spawnY, speed) {
            // Spawn at the boss's left edge
            let projectile = scene.physics.add.sprite(boss.x - 80, spawnY, 'capsid_empty');
            
            projectile.body.setAllowGravity(false);
            projectile.setVelocityX(speed);

            scene.physics.add.overlap(player, projectile, () => {
                if (!player.isInvulnerable) {
                    damagePlayer(player, projectile, scene, 10);
                    player.isInvulnerable = true;
                    projectile.destroy();
                    scene.time.delayedCall(500, () => { player.isInvulnerable = false; });
                }
            });

            // Destroy if it leaves the boss room area (roughly 4 seconds of flight)
            scene.time.delayedCall(4000, () => { 
                if (projectile.active) projectile.destroy(); 
            });
        }

        function hitBoss(boss, tube) {
            let scene = boss.scene; 

            // Match the state name from the new transition loop
            if (bossState === 'vulnerable') {
                let dmg = weaponStats[currentWeapon].damage * (scene.damageMultiplier || 1);
                bossHP -= dmg;
                tube.destroy();
                
                // Bar update
                let percentage = Math.max(0, bossHP / bossMaxHP);
                bossHealthBar.width = 400 * percentage;

                if (bossHP <= 0) {
                    if (bossHealthBar) bossHealthBar.destroy();
                    endGame(scene);
                }
            } else {
                // If defensive or attacking, tubes just break
                tube.destroy();
            }
        }

        function spawnHelperPowerup(scene) {
                scene.time.addEvent({
                    delay: Phaser.Math.Between(10000, 20000), // 10-20 seconds
                    callback: () => {
                        if (bossHP <= 0) return;

                        let x = Phaser.Math.Between(bossRoomShift + 100, bossRoomShift + 600);
                        let type = Phaser.Math.RND.pick(['revit', 'stabilizer']);
                        let pUp = scene.physics.add.sprite(x, -50, type); // Drop from sky
                        
                        scene.physics.add.overlap(player, pUp, () => {
                            applyBossPowerup(type, scene);
                            pUp.destroy();
                        });
                    },
                    loop: true
                });
            }

        function startPowerupDrops(scene) {
            scene.time.addEvent({
                delay: 15000,
                callback: () => {
                    if (bossHP <= 0) return;
                    let dropX = Phaser.Math.Between(scene.bossRoomShift + 50, scene.bossRoomShift + 400);
                    let pUp = scene.physics.add.sprite(dropX, -50, 'powerup_crate');
                    pUp.setGravityY(300);
                    pUp.setCollideWorldBounds(true);
                    scene.physics.add.collider(pUp, scene.platforms);
                    
                    let type = Phaser.Math.RND.pick(['revit', 'stabilizer']);
                    scene.physics.add.overlap(player, pUp, () => {
                        applyBossPowerup(type, scene);
                        pUp.destroy();
                    });
                },
                loop: true
            });
        }

        function applyBossPowerup(type, scene) {
            if (type === 'revit') {
                scene.damageMultiplier = 3;
                scene.time.delayedCall(5000, () => scene.damageMultiplier = 1);
            } else if (type === 'stabilizer') {
                // Slow down active projectiles
                scene.children.list.forEach(child => {
                    if (child.texture && child.texture.key === 'capsid_empty') {
                        child.setVelocityX(-50);
                    }
                });
            }
        }
        
        function endGame(scene) {
            bossState = 'defeated';
            scene.physics.pause();
            if (bossTimer) bossTimer.destroy();

            let totalPoints = scene.score;
            let timeRemaining = scene.timeLeft;

            // The "High-Yield" Curve
            // Squaring the points creates the Xe12 - Xe15 jump at the high end
            let mantissa = timeRemaining * 1.2;
            let exponent = Math.pow(totalPoints, 2) / 722.5;
            
            totalScore = mantissa * Math.pow(10, exponent);
            // // 1. Calculate Exponential Titer based on Scenario Math
            // // Assuming each capsid collected adds 10 to scene.score
            // let capsidsCaptured = scene.score / 10; 
            // let timeRemaining = scene.timeLeft;

            // // The Formula: 390.54 * 10^(capsids/3.5) * 10^(time/110)
            // totalScore = 390.54 * Math.pow(10, (capsidsCaptured / 3.5)) * Math.pow(10, (timeRemaining / 110));
            // // //debug
            // // totalScore = 1.25e14; // Temporary fixed score for testing the results modal
            // // scene.health = 100;

            // Clear the clutter
            scene.children.list.forEach(child => {
                if (child.texture && child.texture.key === 'capsid_empty') child.destroy();
            });
            //Clear HUD
            if (scene.scoreText) scene.scoreText.setVisible(false);
            if (scene.healthText) scene.healthText.setVisible(false);
            if (scene.timerText) scene.timerText.setVisible(false);
            if (scene.toolUI) scene.toolUI.setVisible(false);
            if (bossHealthBar) bossHealthBar.destroy();

            showResultsModal(scene);
        }

        function showResultsModal(scene) {
            let modal = scene.add.container(400, 225).setScrollFactor(0).setDepth(5000);
            let bg = scene.add.image(0, 0, 'modal_bg');
            modal.add(bg);

            let yieldValue = totalScore.toExponential(2); 
            let scoreText = scene.add.text(-180, -50, yieldValue + " GC/mL", { 
                fontSize: '22px', fill: '#ffffff', fontStyle: 'bold', fontFamily: 'Courier New'
            }).setOrigin(0.5);

            let healthValue = Math.max(0, Math.floor(scene.health));
            console.log("Modal Check - Score:", totalScore, "Health:", healthValue);

            let healthText = scene.add.text(-180, 75, healthValue + "%", { 
                fontSize: '22px', fill: '#ffffff', fontStyle: 'bold',fontFamily: 'Courier New'
            }).setOrigin(0.5);

            // Define sprites without playing them yet
            let biz = scene.add.sprite(318, -157, 'avatar_biz').setFrame(0);
            let rnd = scene.add.sprite(318, -53, 'avatar_rnd').setFrame(0);
            let mir = scene.add.sprite(318, 53, 'avatar_mirus').setFrame(0);
            let ply = scene.add.sprite(318, 157, 'avatar_player').setFrame(0);

            modal.add([scoreText, healthText, biz, rnd, mir, ply]);

            // Stochastic Idle Logic
            const setupTwitch = (sprite, animKey) => {
                const playTwitch = () => {
                    // Check if modal still exists before playing (prevents errors on restart)
                    if (!sprite.scene) return; 

                    sprite.play(animKey);
                    sprite.once('animationcomplete', () => {
                        sprite.setFrame(0);
                        scene.time.delayedCall(Phaser.Math.Between(2000, 5000), playTwitch);
                    });
                };
                // Initial offset so they don't start in sync
                scene.time.delayedCall(Phaser.Math.Between(100, 2000), playTwitch);
            };

            setupTwitch(biz, 'loop_biz');
            setupTwitch(rnd, 'loop_rnd');
            setupTwitch(mir, 'loop_mirusteam');
            setupTwitch(ply, 'loop_selfie');

            // SUCCESS THRESHOLD logic remains the same below...
            if (totalScore >= 1e10 && healthValue >= 10) {
                console.log("Condition: WIN");
                scene.time.delayedCall(2000, () => {
                    let prompt = scene.add.text(-180, 160, 'PRODUCTION GOAL MET.\nPRESS SPACE.', { 
                        fontSize: '28px', fill: '#ffff00', fontFamily: 'Courier New', fontStyle: 'bold', backgroundColor: '#000', align: 'center'
                    }).setOrigin(0.5);
                    modal.add(prompt);
                    scene.input.keyboard.once('keydown-SPACE', () => { showSecretCode(modal, scene); });
                });
            } else {
                scene.time.delayedCall(2000, () => {
                    console.log("Condition: FAIL");
                    let retryPrompt = scene.add.text(-180, 160, 'YIELD INSUFFICIENT.\nPRESS SPACE TO RETRY', { 
                        fontSize: '28px', fill: '#ff0000', fontFamily: 'Courier New', fontStyle: 'bold', backgroundColor: '#000', align: 'center'
                    }).setOrigin(0.5);
                    modal.add(retryPrompt);
                    scene.input.keyboard.once('keydown-SPACE', () => { window.location.reload(); });
                });
            }
        }
        function showSecretCode(container, scene) {
            // 1. Cleanup old prompts
            container.list.forEach(item => {
                if (item.text && (item.text.includes('MET') || item.text.includes('SPACE'))) {
                    item.destroy();
                }
            });

            // 2. Top Line (Instruction)
            let instruction = scene.add.text(-180, 125, 'Tell the Table Host this Code\nto Receive Your Envelope:', { 
                fontSize: '14px', 
                fill: '#236085', 
                align: 'center', 
                fontFamily: '"Lucida Console", Monaco, monospace'
            }).setOrigin(0.5);

            // 3. Middle Line (The Brand Code)
            // Using fixed width of 340px via wordWrap and align
            let code = scene.add.text(-180, 175, 'Find your Zen with VirusGEN', { 
                fontSize: '18px', 
                fill: '#ffffff', 
                fontStyle: 'bold', 
                backgroundColor: '#de07ac', 
                padding: { x: 10, y: 10 }, 
                fontFamily: '"Lucida Console", Monaco, monospace',
                align: 'center',
                fixedWidth: 340
            }).setOrigin(0.5);

            // 4. Bottom Line (Restart Info)
            let restartInfo = scene.add.text(140, 185, 'Press Space to Replay', { 
                fontSize: '14px', 
                fill: '#ffffff', 
                backgroundColor: '#236085',
                padding: { x: 5, y: 5 },
                fontFamily: '"Lucida Console", Monaco, monospace'
            }).setOrigin(0.5);

            container.add([instruction, code, restartInfo]);

            // 5. The Double-Check State Gate
            let confirmState = false;

            scene.time.delayedCall(1000, () => {
                scene.input.keyboard.on('keydown-SPACE', () => {
                    if (!confirmState) {
                        // First press: Trigger confirmation
                        confirmState = true;
                        restartInfo.setText('Are you sure?');
                        restartInfo.setBackgroundColor('#ff0000'); // Visual cue for danger
                    } else {
                        // Second press: Execute reload
                        window.location.reload();
                    }
                });
            });
        }

    </script>
</body>
</html>